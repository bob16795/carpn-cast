; ModuleID = 'Context'
source_filename = "Context"

%Vec3 = type { float, float, float }
%Color = type { %Vec3 }
%SolidColor = type { %Color }
%Isotropic = type { %Texture }
%Texture = type { %TextureVTable, ptr }
%TextureVTable = type { ptr }
%Material = type { %MaterialVTable, ptr }
%MaterialVTable = type { ptr, ptr }
%ArrayList.7 = type { i32, i32, ptr }
%ArrayList.8 = type { i32, i32, ptr }
%BHV = type { %Hittable, %Hittable, %AABB }
%Hittable = type { %Vec3, %Vec3, %HittableVTable, ptr }
%HittableVTable = type { ptr, ptr }
%AABB = type { %Interval, %Interval, %Interval }
%Interval = type { float, float }
%ThreadArgs = type { i32, i32, ptr, %Vec3, %Vec3, %Vec3, %Vec3, %Hittable, %Color }
%HRay = type { %Vec3, %Vec3, float }
%HitRecord = type { %Vec3, %Vec3, float, float, float, i1, ptr }
%Lambertian = type { %Texture }
%DiffuseLight = type { %Texture }
%Quad = type { %Vec3, %Vec3, %Vec3, %Vec3, ptr, %Vec3, float, %AABB }
%Group = type { %ArrayList, %AABB }
%ArrayList = type { i32, i32, ptr }
%ArrayList.15 = type { i32, i32, ptr }
%Ray = type { %HRay }

@globalPtr = global ptr null
@str = global [4 x i8] c"lol\00"
@str.43 = global [4 x i8] c"lol\00"
@str.45 = global [4 x i8] c"lol\00"
@str.47 = global [4 x i8] c"lol\00"
@str.49 = global [4 x i8] c"lol\00"
@str.53 = global [4 x i8] c"lol\00"
@str.54 = global [5 x i8] c"lolp\00"
@str.56 = global [5 x i8] c"lolp\00"
@str.58 = global [5 x i8] c"lolp\00"
@str.60 = global [5 x i8] c"lolp\00"
@str.70 = global [2 x i8] c" \00"
@str.71 = global [2 x i8] c" \00"
@str.72 = global [2 x i8] c"\0A\00"

define i32 @main() {
entry:
  %calltmp = call float @pos_0(float 2.780000e+02)
  %calltmp1 = call float @pos_0(float 2.780000e+02)
  %calltmp2 = call float @neg_0(float 8.000000e+02)
  %calltmp3 = call %Vec3 @new_0(float %calltmp, float %calltmp1, float %calltmp2)
  %calltmp4 = call float @pos_0(float 2.780000e+02)
  %calltmp5 = call float @pos_0(float 2.780000e+02)
  %calltmp6 = call float @pos_0(float 0.000000e+00)
  %calltmp7 = call %Vec3 @new_0(float %calltmp4, float %calltmp5, float %calltmp6)
  %calltmp8 = call %Vec3 @new_0(float 0.000000e+00, float 1.000000e+00, float 0.000000e+00)
  %calltmp9 = call %Color @new_0.1(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp10 = call float @degrees_to_radians_0(float 4.000000e+01)
  %divtmp = fdiv float %calltmp10, 2.000000e+00
  %calltmp11 = call float @tanf(float %divtmp)
  %multmp = fmul float %calltmp11, 0x3FF69FBE80000000
  %multmp12 = fmul float 2.000000e+00, %multmp
  %multmp13 = fmul float %multmp12, 0x3FF5555560000000
  %calltmp14 = call %Vec3 @sub_0(%Vec3 %calltmp3, %Vec3 %calltmp7)
  %calltmp15 = call %Vec3 @normal_0(%Vec3 %calltmp14)
  %calltmp16 = call %Vec3 @cross_0(%Vec3 %calltmp8, %Vec3 %calltmp15)
  %calltmp17 = call %Vec3 @normal_0(%Vec3 %calltmp16)
  %calltmp18 = call %Vec3 @cross_0(%Vec3 %calltmp15, %Vec3 %calltmp17)
  %calltmp19 = call %Vec3 @mul_0(%Vec3 %calltmp17, float %multmp13)
  %subtmp = fsub float 0.000000e+00, %multmp12
  %calltmp20 = call %Vec3 @mul_0(%Vec3 %calltmp18, float %subtmp)
  %calltmp21 = call %Vec3 @div_0(%Vec3 %calltmp19, float 6.400000e+02)
  %calltmp22 = call %Vec3 @div_0(%Vec3 %calltmp20, float 4.800000e+02)
  %calltmp23 = call %Vec3 @mul_0(%Vec3 %calltmp15, float 0x3FF69FBE80000000)
  %calltmp24 = call %Vec3 @sub_0(%Vec3 %calltmp3, %Vec3 %calltmp23)
  %calltmp25 = call %Vec3 @div_0(%Vec3 %calltmp19, float 2.000000e+00)
  %calltmp26 = call %Vec3 @sub_0(%Vec3 %calltmp24, %Vec3 %calltmp25)
  %calltmp27 = call %Vec3 @div_0(%Vec3 %calltmp20, float 2.000000e+00)
  %calltmp28 = call %Vec3 @sub_0(%Vec3 %calltmp26, %Vec3 %calltmp27)
  %calltmp29 = call float @degrees_to_radians_0(float 0.000000e+00)
  %calltmp30 = call float @tanf(float %calltmp29)
  %multmp31 = fmul float 0x3FF69FBE80000000, %calltmp30
  %calltmp32 = call %Vec3 @mul_0(%Vec3 %calltmp17, float %multmp31)
  %calltmp33 = call %Vec3 @mul_0(%Vec3 %calltmp18, float %multmp31)
  %calltmp34 = call float @degrees_to_radians_0(float 0.000000e+00)
  %calltmp35 = call float @tanf(float %calltmp34)
  %multmp36 = fmul float 0x3FF69FBE80000000, %calltmp35
  %calltmp37 = call %Vec3 @mul_0(%Vec3 %calltmp17, float %multmp36)
  %calltmp38 = call %Vec3 @mul_0(%Vec3 %calltmp18, float %multmp36)
  %calltmp39 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x [2 x %SolidColor]], ptr null, i32 1) to i32))
  %calltmp40 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x [1 x %Isotropic]], ptr null, i32 1) to i32))
  %elemtemp = getelementptr inbounds [2 x %SolidColor], ptr %calltmp39, i32 0, i32 0
  %calltmp41 = call %Color @new_0.1(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp42 = call %SolidColor @new_0.2(%Color %calltmp41)
  store %SolidColor %calltmp42, ptr %elemtemp, align 4
  %elemtemp43 = getelementptr inbounds [1 x %Isotropic], ptr %calltmp40, i32 0, i32 0
  %elemtemp44 = getelementptr inbounds [2 x %SolidColor], ptr %calltmp39, i32 0, i32 0
  %calltmp45 = call %Texture @new_0.3(ptr %elemtemp44)
  %calltmp46 = call %Isotropic @new_0.4(%Texture %calltmp45)
  store %Isotropic %calltmp46, ptr %elemtemp43, align 8
  %calltmp47 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x [7 x %Material]], ptr null, i32 1) to i32))
  %elemtemp48 = getelementptr inbounds [7 x %Material], ptr %calltmp47, i32 0, i32 0
  %elemtemp49 = getelementptr inbounds [1 x %Isotropic], ptr %calltmp40, i32 0, i32 0
  %calltmp50 = call %Material @new_0.5(ptr %elemtemp49)
  store %Material %calltmp50, ptr %elemtemp48, align 8
  %worldStuff = alloca %ArrayList.7, align 8
  %calltmp51 = call %ArrayList.8 @init_0()
  store %ArrayList.8 %calltmp51, ptr %worldStuff, align 8
  %calltmp52 = call void @cornell_box_0(ptr %worldStuff)
  %world = alloca %BHV, align 8
  %0 = getelementptr inbounds %ArrayList.7, ptr %worldStuff, i32 0, i32 1
  %readtmp = load i32, ptr %0, align 4
  %calltmp53 = call %BHV @new_0.41(ptr %worldStuff, i32 0, i32 %readtmp)
  store %BHV %calltmp53, ptr %world, align 8
  %worldh = alloca %Hittable, align 8
  %calltmp54 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp55 = call %Hittable @new_1.61(ptr %world, %Vec3 %calltmp54)
  store %Hittable %calltmp55, ptr %worldh, align 8
  %s = alloca i64, align 8
  %t = alloca i64, align 8
  %out = alloca ptr, align 8
  %calltmp56 = call ptr @calloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x %Color], ptr null, i32 1) to i32), i32 307200)
  store ptr %calltmp56, ptr %out, align 8
  %tmp_out = alloca ptr, align 8
  %calltmp57 = call ptr @calloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x [3 x i8]], ptr null, i32 1) to i32), i32 307200)
  store ptr %calltmp57, ptr %tmp_out, align 8
  %args = alloca %ThreadArgs, align 8
  %1 = getelementptr inbounds %ThreadArgs, ptr %args, i32 0, i32 0
  store i32 640, ptr %1, align 4
  %2 = getelementptr inbounds %ThreadArgs, ptr %args, i32 0, i32 1
  store i32 480, ptr %2, align 4
  %3 = getelementptr inbounds %ThreadArgs, ptr %args, i32 0, i32 2
  %readtmp58 = load ptr, ptr %out, align 8
  store ptr %readtmp58, ptr %3, align 8
  %4 = getelementptr inbounds %ThreadArgs, ptr %args, i32 0, i32 3
  store %Vec3 %calltmp28, ptr %4, align 4
  %5 = getelementptr inbounds %ThreadArgs, ptr %args, i32 0, i32 4
  store %Vec3 %calltmp21, ptr %5, align 4
  %6 = getelementptr inbounds %ThreadArgs, ptr %args, i32 0, i32 5
  store %Vec3 %calltmp22, ptr %6, align 4
  %7 = getelementptr inbounds %ThreadArgs, ptr %args, i32 0, i32 6
  store %Vec3 %calltmp3, ptr %7, align 4
  %8 = getelementptr inbounds %ThreadArgs, ptr %args, i32 0, i32 7
  %readtmp59 = load %Hittable, ptr %worldh, align 8
  store %Hittable %readtmp59, ptr %8, align 8
  %9 = getelementptr inbounds %ThreadArgs, ptr %args, i32 0, i32 8
  store %Color %calltmp9, ptr %9, align 4
  %calltmp60 = call ptr @malloc(i32 mul (i32 ptrtoint (ptr getelementptr inbounds ([1 x ptr], ptr null, i32 1) to i32), i32 7))
  %calltmp61 = call void @pthread_mutex_init(ptr @globalPtr, ptr null)
  %idx = alloca i32, align 4
  store i64 0, ptr %s, align 4
  store i64 0, ptr %t, align 4
  br label %whilehead

whilehead:                                        ; preds = %ifmerge, %entry
  %readtmp62 = load i64, ptr %s, align 4
  %lttmp = icmp ult i64 %readtmp62, 1000
  %docond = icmp ne i1 %lttmp, false
  br i1 %docond, label %whilebody, label %whilemerge

whilebody:                                        ; preds = %whilehead
  %tmp_int = ptrtoint ptr %calltmp60 to i64
  %readtmp63 = load i64, ptr %t, align 4
  %multmp64 = mul i32 ptrtoint (ptr getelementptr inbounds ([1 x ptr], ptr null, i32 1) to i32), i64 %readtmp63
  %addtmp = add i64 %tmp_int, i32 %multmp64
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  %calltmp65 = call void @pthread_create(ptr %tmp_pointer, ptr null, ptr @thread_0, ptr %args)
  %readtmp66 = load i64, ptr %s, align 4
  %addtmp67 = add i64 %readtmp66, 1
  store i64 %addtmp67, ptr %s, align 4
  %readtmp68 = load i64, ptr %t, align 4
  %addtmp69 = add i64 %readtmp68, 1
  store i64 %addtmp69, ptr %t, align 4
  %readtmp70 = load i64, ptr %s, align 4
  %tmp_float = trunc i64 %readtmp70 to i32
  %calltmp71 = call void @log_pc(i32 %tmp_float, i32 1000)
  %readtmp72 = load i64, ptr %t, align 4
  %gttmp = icmp ugt i64 %readtmp72, 7
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

whilemerge:                                       ; preds = %whilehead
  br label %whilehead119

ifbody:                                           ; preds = %whilebody
  br label %whilehead73

ifmerge:                                          ; preds = %whilemerge90, %whilebody
  br label %whilehead

whilehead73:                                      ; preds = %whilebody74, %ifbody
  %readtmp76 = load i64, ptr %t, align 4
  %gttmp77 = icmp ugt i64 %readtmp76, 0
  %docond78 = icmp ne i1 %gttmp77, false
  br i1 %docond78, label %whilebody74, label %whilemerge75

whilebody74:                                      ; preds = %whilehead73
  %readtmp79 = load i64, ptr %t, align 4
  %subtmp80 = sub i64 %readtmp79, 1
  store i64 %subtmp80, ptr %t, align 4
  %tmp_int81 = ptrtoint ptr %calltmp60 to i64
  %readtmp82 = load i64, ptr %t, align 4
  %multmp83 = mul i32 ptrtoint (ptr getelementptr inbounds ([1 x ptr], ptr null, i32 1) to i32), i64 %readtmp82
  %addtmp84 = add i64 %tmp_int81, i32 %multmp83
  %tmp_pointer85 = inttoptr i64 %addtmp84 to ptr
  %readtmp86 = load ptr, ptr %tmp_pointer85, align 8
  %calltmp87 = call void @pthread_join(ptr %readtmp86, ptr null)
  br label %whilehead73

whilemerge75:                                     ; preds = %whilehead73
  store i32 0, ptr %idx, align 4
  br label %whilehead88

whilehead88:                                      ; preds = %whilebody89, %whilemerge75
  %readtmp91 = load i32, ptr %idx, align 4
  %lttmp92 = icmp ult i32 %readtmp91, i64 307200
  %docond93 = icmp ne i1 %lttmp92, false
  br i1 %docond93, label %whilebody89, label %whilemerge90

whilebody89:                                      ; preds = %whilehead88
  %readtmp94 = load ptr, ptr %out, align 8
  %tmp_int95 = ptrtoint ptr %readtmp94 to i64
  %readtmp96 = load i32, ptr %idx, align 4
  %tmp_float97 = zext i32 %readtmp96 to i64
  %multmp98 = mul i64 zext (i32 ptrtoint (ptr getelementptr inbounds ([1 x %Color], ptr null, i32 1) to i32) to i64), %tmp_float97
  %addtmp99 = add i64 %tmp_int95, %multmp98
  %tmp_pointer100 = inttoptr i64 %addtmp99 to ptr
  %readtmp101 = load ptr, ptr %tmp_out, align 8
  %tmp_int102 = ptrtoint ptr %readtmp101 to i64
  %readtmp103 = load i32, ptr %idx, align 4
  %tmp_float104 = zext i32 %readtmp103 to i64
  %multmp105 = mul i64 zext (i32 ptrtoint (ptr getelementptr inbounds ([1 x [3 x i8]], ptr null, i32 1) to i32) to i64), %tmp_float104
  %addtmp106 = add i64 %tmp_int102, %multmp105
  %tmp_pointer107 = inttoptr i64 %addtmp106 to ptr
  %readtmp108 = load %Color, ptr %tmp_pointer100, align 4
  %readtmp109 = load i64, ptr %s, align 4
  %tmp_float110 = uitofp i64 %readtmp109 to float
  %calltmp111 = call [3 x i8] @bytes_0(%Color %readtmp108, float %tmp_float110)
  store [3 x i8] %calltmp111, ptr %tmp_pointer107, align 1
  %readtmp112 = load i32, ptr %idx, align 4
  %addtmp113 = add i32 %readtmp112, 1
  store i32 %addtmp113, ptr %idx, align 4
  br label %whilehead88

whilemerge90:                                     ; preds = %whilehead88
  %readtmp114 = load i64, ptr %s, align 4
  %tmp_float115 = trunc i64 %readtmp114 to i32
  %calltmp116 = call ptr @get_name(i32 %tmp_float115)
  %readtmp117 = load ptr, ptr %tmp_out, align 8
  %calltmp118 = call void @stbi_write_png(ptr %calltmp116, i32 640, i32 480, i32 3, ptr %readtmp117, i32 1920)
  br label %ifmerge

whilehead119:                                     ; preds = %whilebody120, %whilemerge
  %readtmp122 = load i64, ptr %t, align 4
  %gttmp123 = icmp ugt i64 %readtmp122, 0
  %docond124 = icmp ne i1 %gttmp123, false
  br i1 %docond124, label %whilebody120, label %whilemerge121

whilebody120:                                     ; preds = %whilehead119
  %readtmp125 = load i64, ptr %t, align 4
  %subtmp126 = sub i64 %readtmp125, 1
  store i64 %subtmp126, ptr %t, align 4
  %tmp_int127 = ptrtoint ptr %calltmp60 to i64
  %readtmp128 = load i64, ptr %t, align 4
  %multmp129 = mul i32 ptrtoint (ptr getelementptr inbounds ([1 x ptr], ptr null, i32 1) to i32), i64 %readtmp128
  %addtmp130 = add i64 %tmp_int127, i32 %multmp129
  %tmp_pointer131 = inttoptr i64 %addtmp130 to ptr
  %readtmp132 = load ptr, ptr %tmp_pointer131, align 8
  %calltmp133 = call void @pthread_join(ptr %readtmp132, ptr null)
  br label %whilehead119

whilemerge121:                                    ; preds = %whilehead119
  store i32 0, ptr %idx, align 4
  br label %whilehead134

whilehead134:                                     ; preds = %whilebody135, %whilemerge121
  %readtmp137 = load i32, ptr %idx, align 4
  %lttmp138 = icmp ult i32 %readtmp137, i64 307200
  %docond139 = icmp ne i1 %lttmp138, false
  br i1 %docond139, label %whilebody135, label %whilemerge136

whilebody135:                                     ; preds = %whilehead134
  %readtmp140 = load ptr, ptr %out, align 8
  %tmp_int141 = ptrtoint ptr %readtmp140 to i64
  %readtmp142 = load i32, ptr %idx, align 4
  %tmp_float143 = zext i32 %readtmp142 to i64
  %multmp144 = mul i64 zext (i32 ptrtoint (ptr getelementptr inbounds ([1 x %Color], ptr null, i32 1) to i32) to i64), %tmp_float143
  %addtmp145 = add i64 %tmp_int141, %multmp144
  %tmp_pointer146 = inttoptr i64 %addtmp145 to ptr
  %readtmp147 = load %Color, ptr %tmp_pointer146, align 4
  %readtmp148 = load i64, ptr %s, align 4
  %tmp_float149 = uitofp i64 %readtmp148 to float
  %calltmp150 = call void @write_0(%Color %readtmp147, float %tmp_float149)
  %readtmp151 = load i32, ptr %idx, align 4
  %addtmp152 = add i32 %readtmp151, 1
  store i32 %addtmp152, ptr %idx, align 4
  br label %whilehead134

whilemerge136:                                    ; preds = %whilehead134
  ret i32 0
}

define float @pos_0(float %0) {
entry:
  ret float %0
}

define float @neg_0(float %0) {
entry:
  %subtmp = fsub float 0.000000e+00, %0
  ret float %subtmp
}

define %Vec3 @new_0(float %0, float %1, float %2) {
entry:
  %result = alloca %Vec3, align 8
  %3 = getelementptr inbounds %Vec3, ptr %result, i32 0, i32 2
  store float %2, ptr %3, align 4
  %4 = getelementptr inbounds %Vec3, ptr %result, i32 0, i32 1
  store float %1, ptr %4, align 4
  %5 = getelementptr inbounds %Vec3, ptr %result, i32 0, i32 0
  store float %0, ptr %5, align 4
  %readtmp = load %Vec3, ptr %result, align 4
  ret %Vec3 %readtmp
}

define %Color @new_0.1(float %0, float %1, float %2) {
entry:
  %result = alloca %Color, align 8
  %3 = getelementptr inbounds %Color, ptr %result, i32 0, i32 0
  %4 = getelementptr inbounds %Vec3, ptr %3, i32 0, i32 2
  store float %2, ptr %4, align 4
  %5 = getelementptr inbounds %Color, ptr %result, i32 0, i32 0
  %6 = getelementptr inbounds %Vec3, ptr %5, i32 0, i32 1
  store float %1, ptr %6, align 4
  %7 = getelementptr inbounds %Color, ptr %result, i32 0, i32 0
  %8 = getelementptr inbounds %Vec3, ptr %7, i32 0, i32 0
  store float %0, ptr %8, align 4
  %readtmp = load %Color, ptr %result, align 4
  ret %Color %readtmp
}

define float @degrees_to_radians_0(float %0) {
entry:
  %multmp = fmul float %0, 0x3F91DE69A0000000
  ret float %multmp
}

declare float @tanf(float)

define %Vec3 @sub_0(%Vec3 %0, %Vec3 %1) {
entry:
  %extracted = extractvalue %Vec3 %0, 0
  %extracted1 = extractvalue %Vec3 %1, 0
  %subtmp = fsub float %extracted, %extracted1
  %extracted2 = extractvalue %Vec3 %0, 1
  %extracted3 = extractvalue %Vec3 %1, 1
  %subtmp4 = fsub float %extracted2, %extracted3
  %extracted5 = extractvalue %Vec3 %0, 2
  %extracted6 = extractvalue %Vec3 %1, 2
  %subtmp7 = fsub float %extracted5, %extracted6
  %calltmp = call %Vec3 @new_0(float %subtmp, float %subtmp4, float %subtmp7)
  ret %Vec3 %calltmp
}

define %Vec3 @normal_0(%Vec3 %0) {
entry:
  %calltmp = call float @mag_0(%Vec3 %0)
  %calltmp1 = call %Vec3 @div_0(%Vec3 %0, float %calltmp)
  ret %Vec3 %calltmp1
}

define float @mag_0(%Vec3 %0) {
entry:
  %calltmp = call float @dot_0(%Vec3 %0, %Vec3 %0)
  %calltmp1 = call float @sqrtf(float %calltmp)
  ret float %calltmp1
}

define float @dot_0(%Vec3 %0, %Vec3 %1) {
entry:
  %extracted = extractvalue %Vec3 %0, 0
  %extracted1 = extractvalue %Vec3 %1, 0
  %multmp = fmul float %extracted, %extracted1
  %extracted2 = extractvalue %Vec3 %0, 1
  %extracted3 = extractvalue %Vec3 %1, 1
  %multmp4 = fmul float %extracted2, %extracted3
  %addtmp = fadd float %multmp, %multmp4
  %extracted5 = extractvalue %Vec3 %0, 2
  %extracted6 = extractvalue %Vec3 %1, 2
  %multmp7 = fmul float %extracted5, %extracted6
  %addtmp8 = fadd float %addtmp, %multmp7
  ret float %addtmp8
}

declare float @sqrtf(float)

define %Vec3 @div_0(%Vec3 %0, float %1) {
entry:
  %extracted = extractvalue %Vec3 %0, 0
  %divtmp = fdiv float %extracted, %1
  %extracted1 = extractvalue %Vec3 %0, 1
  %divtmp2 = fdiv float %extracted1, %1
  %extracted3 = extractvalue %Vec3 %0, 2
  %divtmp4 = fdiv float %extracted3, %1
  %calltmp = call %Vec3 @new_0(float %divtmp, float %divtmp2, float %divtmp4)
  ret %Vec3 %calltmp
}

define %Vec3 @cross_0(%Vec3 %0, %Vec3 %1) {
entry:
  %extracted = extractvalue %Vec3 %1, 1
  %extracted1 = extractvalue %Vec3 %0, 2
  %multmp = fmul float %extracted, %extracted1
  %extracted2 = extractvalue %Vec3 %1, 2
  %extracted3 = extractvalue %Vec3 %0, 1
  %multmp4 = fmul float %extracted2, %extracted3
  %subtmp = fsub float %multmp, %multmp4
  %extracted5 = extractvalue %Vec3 %1, 2
  %extracted6 = extractvalue %Vec3 %0, 0
  %multmp7 = fmul float %extracted5, %extracted6
  %extracted8 = extractvalue %Vec3 %1, 0
  %extracted9 = extractvalue %Vec3 %0, 2
  %multmp10 = fmul float %extracted8, %extracted9
  %subtmp11 = fsub float %multmp7, %multmp10
  %extracted12 = extractvalue %Vec3 %1, 0
  %extracted13 = extractvalue %Vec3 %0, 1
  %multmp14 = fmul float %extracted12, %extracted13
  %extracted15 = extractvalue %Vec3 %1, 1
  %extracted16 = extractvalue %Vec3 %0, 0
  %multmp17 = fmul float %extracted15, %extracted16
  %subtmp18 = fsub float %multmp14, %multmp17
  %calltmp = call %Vec3 @new_0(float %subtmp, float %subtmp11, float %subtmp18)
  ret %Vec3 %calltmp
}

define %Vec3 @mul_0(%Vec3 %0, float %1) {
entry:
  %extracted = extractvalue %Vec3 %0, 0
  %multmp = fmul float %extracted, %1
  %extracted1 = extractvalue %Vec3 %0, 1
  %multmp2 = fmul float %extracted1, %1
  %extracted3 = extractvalue %Vec3 %0, 2
  %multmp4 = fmul float %extracted3, %1
  %calltmp = call %Vec3 @new_0(float %multmp, float %multmp2, float %multmp4)
  ret %Vec3 %calltmp
}

declare ptr @malloc(i32)

define %SolidColor @new_0.2(%Color %0) {
entry:
  %result = alloca %SolidColor, align 8
  %1 = getelementptr inbounds %SolidColor, ptr %result, i32 0, i32 0
  store %Color %0, ptr %1, align 4
  %readtmp = load %SolidColor, ptr %result, align 4
  ret %SolidColor %readtmp
}

define %Texture @new_0.3(ptr %0) {
entry:
  %result = alloca %Texture, align 8
  %readtmp = load %SolidColor, ptr %0, align 4
  %1 = getelementptr inbounds %Texture, ptr %result, i32 0, i32 0
  %2 = getelementptr inbounds %TextureVTable, ptr %1, i32 0, i32 0
  store ptr @value_0, ptr %2, align 8
  %3 = getelementptr inbounds %Texture, ptr %result, i32 0, i32 1
  store ptr %0, ptr %3, align 8
  %readtmp1 = load %Texture, ptr %result, align 8
  ret %Texture %readtmp1
}

define %Color @value_0(ptr %0, float %1, float %2, ptr %3) {
entry:
  %4 = getelementptr inbounds %SolidColor, ptr %0, i32 0, i32 0
  %readtmp = load %Color, ptr %4, align 4
  ret %Color %readtmp
}

define %Isotropic @new_0.4(%Texture %0) {
entry:
  %result = alloca %Isotropic, align 8
  %1 = getelementptr inbounds %Isotropic, ptr %result, i32 0, i32 0
  store %Texture %0, ptr %1, align 8
  %readtmp = load %Isotropic, ptr %result, align 8
  ret %Isotropic %readtmp
}

define %Material @new_0.5(ptr %0) {
entry:
  %result = alloca %Material, align 8
  %readtmp = load %Isotropic, ptr %0, align 8
  %1 = getelementptr inbounds %Material, ptr %result, i32 0, i32 0
  %2 = getelementptr inbounds %MaterialVTable, ptr %1, i32 0, i32 0
  store ptr @scatter_0, ptr %2, align 8
  %3 = getelementptr inbounds %Material, ptr %result, i32 0, i32 0
  %4 = getelementptr inbounds %MaterialVTable, ptr %3, i32 0, i32 1
  store ptr @emit_0, ptr %4, align 8
  %5 = getelementptr inbounds %Material, ptr %result, i32 0, i32 1
  store ptr %0, ptr %5, align 8
  %readtmp1 = load %Material, ptr %result, align 8
  ret %Material %readtmp1
}

define i1 @scatter_0(ptr %0, %HRay %1, ptr %2, ptr %3, ptr %4) {
entry:
  %5 = getelementptr inbounds %HRay, ptr %4, i32 0, i32 0
  %6 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 0
  %readtmp = load %Vec3, ptr %6, align 4
  store %Vec3 %readtmp, ptr %5, align 4
  %7 = getelementptr inbounds %HRay, ptr %4, i32 0, i32 1
  %calltmp = call %Vec3 @random_unit_vector_0()
  store %Vec3 %calltmp, ptr %7, align 4
  %8 = getelementptr inbounds %HRay, ptr %4, i32 0, i32 2
  %extracted = extractvalue %HRay %1, 2
  store float %extracted, ptr %8, align 4
  %9 = getelementptr inbounds %Isotropic, ptr %0, i32 0, i32 0
  %readtmp1 = load %Texture, ptr %9, align 8
  %10 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 3
  %readtmp2 = load float, ptr %10, align 4
  %11 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 4
  %readtmp3 = load float, ptr %11, align 4
  %12 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 0
  %calltmp4 = call %Color @value_0.6(%Texture %readtmp1, float %readtmp2, float %readtmp3, ptr %12)
  store %Color %calltmp4, ptr %3, align 4
  ret i1 true
}

define %Vec3 @random_unit_vector_0() {
entry:
  %calltmp = call %Vec3 @random_in_unit_sphere_0()
  %calltmp1 = call %Vec3 @normal_0(%Vec3 %calltmp)
  ret %Vec3 %calltmp1
}

define %Vec3 @random_in_unit_sphere_0() {
entry:
  %result = alloca %Vec3, align 8
  br label %dobody

dobody:                                           ; preds = %dobody, %entry
  %calltmp = call %Vec3 @random_0(float -1.000000e+00, float 1.000000e+00)
  store %Vec3 %calltmp, ptr %result, align 4
  %readtmp = load %Vec3, ptr %result, align 4
  %readtmp1 = load %Vec3, ptr %result, align 4
  %calltmp2 = call float @dot_0(%Vec3 %readtmp, %Vec3 %readtmp1)
  %lttmp = fcmp ule float %calltmp2, 1.000000e+00
  %docond = icmp ne i1 %lttmp, false
  br i1 %docond, label %dobody, label %domerge

domerge:                                          ; preds = %dobody
  %readtmp3 = load %Vec3, ptr %result, align 4
  ret %Vec3 %readtmp3
}

define %Vec3 @random_0(float %0, float %1) {
entry:
  %tmp_ext = fpext float %1 to double
  %tmp_ext1 = fpext float %0 to double
  %calltmp = call double @random_double(double %tmp_ext1, double %tmp_ext)
  %tmp_trunc = fptrunc double %calltmp to float
  %calltmp2 = call double @random_double(double %tmp_ext1, double %tmp_ext)
  %tmp_trunc3 = fptrunc double %calltmp2 to float
  %calltmp4 = call double @random_double(double %tmp_ext1, double %tmp_ext)
  %tmp_trunc5 = fptrunc double %calltmp4 to float
  %calltmp6 = call %Vec3 @new_0(float %tmp_trunc, float %tmp_trunc3, float %tmp_trunc5)
  ret %Vec3 %calltmp6
}

declare double @random_double(double, double)

define %Color @value_0.6(%Texture %0, float %1, float %2, ptr %3) {
entry:
  %extracted = extractvalue %Texture %0, 1
  %extracted1 = extractvalue %Texture %0, 0
  %extracted2 = extractvalue %TextureVTable %extracted1, 0
  %calltmp = call %Color %extracted2(ptr %extracted, float %1, float %2, ptr %3)
  ret %Color %calltmp
}

define %Color @emit_0(ptr %0, float %1, float %2, %Vec3 %3) {
entry:
  %calltmp = call %Color @new_0.1(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  ret %Color %calltmp
}

define %ArrayList.8 @init_0() {
entry:
  %result = alloca %ArrayList.8, align 8
  %0 = getelementptr inbounds %ArrayList.8, ptr %result, i32 0, i32 1
  store i32 0, ptr %0, align 4
  %1 = getelementptr inbounds %ArrayList.8, ptr %result, i32 0, i32 0
  store i32 0, ptr %1, align 4
  %2 = getelementptr inbounds %ArrayList.8, ptr %result, i32 0, i32 2
  store ptr null, ptr %2, align 8
  %readtmp = load %ArrayList.8, ptr %result, align 8
  ret %ArrayList.8 %readtmp
}

define void @cornell_box_0(ptr %0) {
entry:
  %calltmp = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x [4 x %SolidColor]], ptr null, i32 1) to i32))
  %elemtemp = getelementptr inbounds [4 x %SolidColor], ptr %calltmp, i32 0, i32 0
  %calltmp1 = call %Color @new_0.1(float 0x3FE4CCCCC0000000, float 0x3FA99999A0000000, float 0x3FA99999A0000000)
  %calltmp2 = call %SolidColor @new_0.2(%Color %calltmp1)
  store %SolidColor %calltmp2, ptr %elemtemp, align 4
  %elemtemp3 = getelementptr inbounds [4 x %SolidColor], ptr %calltmp, i32 0, i32 1
  %calltmp4 = call %Color @new_0.1(float 0x3FE75C2900000000, float 0x3FE75C2900000000, float 0x3FE75C2900000000)
  %calltmp5 = call %SolidColor @new_0.2(%Color %calltmp4)
  store %SolidColor %calltmp5, ptr %elemtemp3, align 4
  %elemtemp6 = getelementptr inbounds [4 x %SolidColor], ptr %calltmp, i32 0, i32 2
  %calltmp7 = call %Color @new_0.1(float 0x3FBEB851E0000000, float 0x3FDCCCCCC0000000, float 0x3FC3333340000000)
  %calltmp8 = call %SolidColor @new_0.2(%Color %calltmp7)
  store %SolidColor %calltmp8, ptr %elemtemp6, align 4
  %elemtemp9 = getelementptr inbounds [4 x %SolidColor], ptr %calltmp, i32 0, i32 3
  %calltmp10 = call %Color @new_0.1(float 7.000000e+00, float 7.000000e+00, float 7.000000e+00)
  %calltmp11 = call %SolidColor @new_0.2(%Color %calltmp10)
  store %SolidColor %calltmp11, ptr %elemtemp9, align 4
  %calltmp12 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x %Lambertian], ptr null, i32 1) to i32))
  %calltmp13 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x %Lambertian], ptr null, i32 1) to i32))
  %calltmp14 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x %Lambertian], ptr null, i32 1) to i32))
  %calltmp15 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x %DiffuseLight], ptr null, i32 1) to i32))
  %elemtemp16 = getelementptr inbounds [4 x %SolidColor], ptr %calltmp, i32 0, i32 0
  %calltmp17 = call %Texture @new_0.3(ptr %elemtemp16)
  %calltmp18 = call %Lambertian @new_0.7(%Texture %calltmp17)
  store %Lambertian %calltmp18, ptr %calltmp12, align 8
  %elemtemp19 = getelementptr inbounds [4 x %SolidColor], ptr %calltmp, i32 0, i32 1
  %calltmp20 = call %Texture @new_0.3(ptr %elemtemp19)
  %calltmp21 = call %Lambertian @new_0.7(%Texture %calltmp20)
  store %Lambertian %calltmp21, ptr %calltmp13, align 8
  %elemtemp22 = getelementptr inbounds [4 x %SolidColor], ptr %calltmp, i32 0, i32 2
  %calltmp23 = call %Texture @new_0.3(ptr %elemtemp22)
  %calltmp24 = call %Lambertian @new_0.7(%Texture %calltmp23)
  store %Lambertian %calltmp24, ptr %calltmp14, align 8
  %elemtemp25 = getelementptr inbounds [4 x %SolidColor], ptr %calltmp, i32 0, i32 3
  %calltmp26 = call %Texture @new_0.3(ptr %elemtemp25)
  %calltmp27 = call %DiffuseLight @new_0.8(%Texture %calltmp26)
  store %DiffuseLight %calltmp27, ptr %calltmp15, align 8
  %calltmp28 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x [4 x %Material]], ptr null, i32 1) to i32))
  %elemtemp29 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 0
  %calltmp30 = call %Material @new_1(ptr %calltmp14)
  store %Material %calltmp30, ptr %elemtemp29, align 8
  %elemtemp31 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 1
  %calltmp32 = call %Material @new_1(ptr %calltmp12)
  store %Material %calltmp32, ptr %elemtemp31, align 8
  %elemtemp33 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 2
  %calltmp34 = call %Material @new_1(ptr %calltmp13)
  store %Material %calltmp34, ptr %elemtemp33, align 8
  %elemtemp35 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 3
  %calltmp36 = call %Material @new_2(ptr %calltmp15)
  store %Material %calltmp36, ptr %elemtemp35, align 8
  %calltmp37 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x [6 x %Quad]], ptr null, i32 1) to i32))
  %elemtemp38 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 0
  %calltmp39 = call %Vec3 @new_0(float 5.550000e+02, float 0.000000e+00, float 0.000000e+00)
  %calltmp40 = call %Vec3 @new_0(float 0.000000e+00, float 5.550000e+02, float 0.000000e+00)
  %calltmp41 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 5.550000e+02)
  %elemtemp42 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 0
  %calltmp43 = call %Quad @new_0.13(%Vec3 %calltmp39, %Vec3 %calltmp40, %Vec3 %calltmp41, ptr %elemtemp42)
  store %Quad %calltmp43, ptr %elemtemp38, align 8
  %elemtemp44 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 1
  %calltmp45 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp46 = call %Vec3 @new_0(float 0.000000e+00, float 5.550000e+02, float 0.000000e+00)
  %calltmp47 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 5.550000e+02)
  %elemtemp48 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 1
  %calltmp49 = call %Quad @new_0.13(%Vec3 %calltmp45, %Vec3 %calltmp46, %Vec3 %calltmp47, ptr %elemtemp48)
  store %Quad %calltmp49, ptr %elemtemp44, align 8
  %elemtemp50 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 2
  %calltmp51 = call %Vec3 @new_0(float 1.130000e+02, float 5.540000e+02, float 1.270000e+02)
  %calltmp52 = call %Vec3 @new_0(float 3.300000e+02, float 0.000000e+00, float 0.000000e+00)
  %calltmp53 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 3.050000e+02)
  %elemtemp54 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 3
  %calltmp55 = call %Quad @new_0.13(%Vec3 %calltmp51, %Vec3 %calltmp52, %Vec3 %calltmp53, ptr %elemtemp54)
  store %Quad %calltmp55, ptr %elemtemp50, align 8
  %elemtemp56 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 3
  %calltmp57 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp58 = call %Vec3 @new_0(float 5.550000e+02, float 0.000000e+00, float 0.000000e+00)
  %calltmp59 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 5.550000e+02)
  %elemtemp60 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 2
  %calltmp61 = call %Quad @new_0.13(%Vec3 %calltmp57, %Vec3 %calltmp58, %Vec3 %calltmp59, ptr %elemtemp60)
  store %Quad %calltmp61, ptr %elemtemp56, align 8
  %elemtemp62 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 4
  %calltmp63 = call %Vec3 @new_0(float 5.550000e+02, float 5.550000e+02, float 5.550000e+02)
  %calltmp64 = call %Vec3 @new_0(float -5.550000e+02, float 0.000000e+00, float 0.000000e+00)
  %calltmp65 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float -5.550000e+02)
  %elemtemp66 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 2
  %calltmp67 = call %Quad @new_0.13(%Vec3 %calltmp63, %Vec3 %calltmp64, %Vec3 %calltmp65, ptr %elemtemp66)
  store %Quad %calltmp67, ptr %elemtemp62, align 8
  %elemtemp68 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 5
  %calltmp69 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 5.550000e+02)
  %calltmp70 = call %Vec3 @new_0(float 5.550000e+02, float 0.000000e+00, float 0.000000e+00)
  %calltmp71 = call %Vec3 @new_0(float 0.000000e+00, float 5.550000e+02, float 0.000000e+00)
  %elemtemp72 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 2
  %calltmp73 = call %Quad @new_0.13(%Vec3 %calltmp69, %Vec3 %calltmp70, %Vec3 %calltmp71, ptr %elemtemp72)
  store %Quad %calltmp73, ptr %elemtemp68, align 8
  %elemtemp74 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 0
  %calltmp75 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp76 = call %Hittable @new_0.15(ptr %elemtemp74, %Vec3 %calltmp75)
  %calltmp77 = call void @append_0(ptr %0, %Hittable %calltmp76)
  %elemtemp78 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 1
  %calltmp79 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp80 = call %Hittable @new_0.15(ptr %elemtemp78, %Vec3 %calltmp79)
  %calltmp81 = call void @append_0.16(ptr %0, %Hittable %calltmp80)
  %elemtemp82 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 2
  %calltmp83 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp84 = call %Hittable @new_0.15(ptr %elemtemp82, %Vec3 %calltmp83)
  %calltmp85 = call void @append_0.18(ptr %0, %Hittable %calltmp84)
  %elemtemp86 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 3
  %calltmp87 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp88 = call %Hittable @new_0.15(ptr %elemtemp86, %Vec3 %calltmp87)
  %calltmp89 = call void @append_0.20(ptr %0, %Hittable %calltmp88)
  %elemtemp90 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 4
  %calltmp91 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp92 = call %Hittable @new_0.15(ptr %elemtemp90, %Vec3 %calltmp91)
  %calltmp93 = call void @append_0.22(ptr %0, %Hittable %calltmp92)
  %elemtemp94 = getelementptr inbounds [6 x %Quad], ptr %calltmp37, i32 0, i32 5
  %calltmp95 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp96 = call %Hittable @new_0.15(ptr %elemtemp94, %Vec3 %calltmp95)
  %calltmp97 = call void @append_0.24(ptr %0, %Hittable %calltmp96)
  %calltmp98 = call %Vec3 @new_0(float 1.300000e+02, float 0.000000e+00, float 6.500000e+01)
  %calltmp99 = call %Vec3 @new_0(float 2.950000e+02, float 1.650000e+02, float 2.300000e+02)
  %elemtemp100 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 2
  %calltmp101 = call void @create_box_0(ptr %0, %Vec3 %calltmp98, %Vec3 %calltmp99, ptr %elemtemp100)
  %calltmp102 = call %Vec3 @new_0(float 2.650000e+02, float 0.000000e+00, float 2.950000e+02)
  %calltmp103 = call %Vec3 @new_0(float 4.300000e+02, float 3.300000e+02, float 4.600000e+02)
  %elemtemp104 = getelementptr inbounds [4 x %Material], ptr %calltmp28, i32 0, i32 2
  %calltmp105 = call void @create_box_0(ptr %0, %Vec3 %calltmp102, %Vec3 %calltmp103, ptr %elemtemp104)
  ret void
}

define %Lambertian @new_0.7(%Texture %0) {
entry:
  %result = alloca %Lambertian, align 8
  %1 = getelementptr inbounds %Lambertian, ptr %result, i32 0, i32 0
  store %Texture %0, ptr %1, align 8
  %readtmp = load %Lambertian, ptr %result, align 8
  ret %Lambertian %readtmp
}

define %DiffuseLight @new_0.8(%Texture %0) {
entry:
  %result = alloca %DiffuseLight, align 8
  %1 = getelementptr inbounds %DiffuseLight, ptr %result, i32 0, i32 0
  store %Texture %0, ptr %1, align 8
  %readtmp = load %DiffuseLight, ptr %result, align 8
  ret %DiffuseLight %readtmp
}

define %Material @new_1(ptr %0) {
entry:
  %result = alloca %Material, align 8
  %readtmp = load %Lambertian, ptr %0, align 8
  %1 = getelementptr inbounds %Material, ptr %result, i32 0, i32 0
  %2 = getelementptr inbounds %MaterialVTable, ptr %1, i32 0, i32 0
  store ptr @scatter_0.9, ptr %2, align 8
  %3 = getelementptr inbounds %Material, ptr %result, i32 0, i32 0
  %4 = getelementptr inbounds %MaterialVTable, ptr %3, i32 0, i32 1
  store ptr @emit_0.10, ptr %4, align 8
  %5 = getelementptr inbounds %Material, ptr %result, i32 0, i32 1
  store ptr %0, ptr %5, align 8
  %readtmp1 = load %Material, ptr %result, align 8
  ret %Material %readtmp1
}

define i1 @scatter_0.9(ptr %0, %HRay %1, ptr %2, ptr %3, ptr %4) {
entry:
  %scatter_direction = alloca %Vec3, align 8
  %5 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 1
  %readtmp = load %Vec3, ptr %5, align 4
  %calltmp = call %Vec3 @random_unit_vector_0()
  %calltmp1 = call %Vec3 @add_0(%Vec3 %readtmp, %Vec3 %calltmp)
  store %Vec3 %calltmp1, ptr %scatter_direction, align 4
  %readtmp2 = load %Vec3, ptr %scatter_direction, align 4
  %calltmp3 = call i1 @near_zero_0(%Vec3 %readtmp2)
  %ifcond = icmp ne i1 %calltmp3, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %6 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 1
  %readtmp4 = load %Vec3, ptr %6, align 4
  store %Vec3 %readtmp4, ptr %scatter_direction, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %7 = getelementptr inbounds %HRay, ptr %4, i32 0, i32 0
  %8 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 0
  %readtmp5 = load %Vec3, ptr %8, align 4
  store %Vec3 %readtmp5, ptr %7, align 4
  %9 = getelementptr inbounds %HRay, ptr %4, i32 0, i32 1
  %readtmp6 = load %Vec3, ptr %scatter_direction, align 4
  store %Vec3 %readtmp6, ptr %9, align 4
  %10 = getelementptr inbounds %HRay, ptr %4, i32 0, i32 2
  %extracted = extractvalue %HRay %1, 2
  store float %extracted, ptr %10, align 4
  %11 = getelementptr inbounds %Lambertian, ptr %0, i32 0, i32 0
  %readtmp7 = load %Texture, ptr %11, align 8
  %12 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 3
  %readtmp8 = load float, ptr %12, align 4
  %13 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 4
  %readtmp9 = load float, ptr %13, align 4
  %14 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 0
  %calltmp10 = call %Color @value_0.6(%Texture %readtmp7, float %readtmp8, float %readtmp9, ptr %14)
  store %Color %calltmp10, ptr %3, align 4
  ret i1 true
}

define %Vec3 @add_0(%Vec3 %0, %Vec3 %1) {
entry:
  %extracted = extractvalue %Vec3 %0, 0
  %extracted1 = extractvalue %Vec3 %1, 0
  %addtmp = fadd float %extracted, %extracted1
  %extracted2 = extractvalue %Vec3 %0, 1
  %extracted3 = extractvalue %Vec3 %1, 1
  %addtmp4 = fadd float %extracted2, %extracted3
  %extracted5 = extractvalue %Vec3 %0, 2
  %extracted6 = extractvalue %Vec3 %1, 2
  %addtmp7 = fadd float %extracted5, %extracted6
  %calltmp = call %Vec3 @new_0(float %addtmp, float %addtmp4, float %addtmp7)
  ret %Vec3 %calltmp
}

define i1 @near_zero_0(%Vec3 %0) {
entry:
  %extracted = extractvalue %Vec3 %0, 0
  %calltmp = call float @fabsf(float %extracted)
  %lttmp = fcmp ule float %calltmp, 0x3EE4F8B580000000
  %extracted1 = extractvalue %Vec3 %0, 1
  %calltmp2 = call float @fabsf(float %extracted1)
  %lttmp3 = fcmp ule float %calltmp2, 0x3EE4F8B580000000
  %subtmp = and i1 %lttmp, %lttmp3
  %extracted4 = extractvalue %Vec3 %0, 2
  %calltmp5 = call float @fabsf(float %extracted4)
  %lttmp6 = fcmp ule float %calltmp5, 0x3EE4F8B580000000
  %subtmp7 = and i1 %subtmp, %lttmp6
  ret i1 %subtmp7
}

declare float @fabsf(float)

define %Color @emit_0.10(ptr %0, float %1, float %2, %Vec3 %3) {
entry:
  %calltmp = call %Color @new_0.1(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  ret %Color %calltmp
}

define %Material @new_2(ptr %0) {
entry:
  %result = alloca %Material, align 8
  %readtmp = load %DiffuseLight, ptr %0, align 8
  %1 = getelementptr inbounds %Material, ptr %result, i32 0, i32 0
  %2 = getelementptr inbounds %MaterialVTable, ptr %1, i32 0, i32 0
  store ptr @scatter_0.11, ptr %2, align 8
  %3 = getelementptr inbounds %Material, ptr %result, i32 0, i32 0
  %4 = getelementptr inbounds %MaterialVTable, ptr %3, i32 0, i32 1
  store ptr @emit_0.12, ptr %4, align 8
  %5 = getelementptr inbounds %Material, ptr %result, i32 0, i32 1
  store ptr %0, ptr %5, align 8
  %readtmp1 = load %Material, ptr %result, align 8
  ret %Material %readtmp1
}

define i1 @scatter_0.11(ptr %0, %HRay %1, ptr %2, ptr %3, ptr %4) {
entry:
  ret i1 false
}

define %Color @emit_0.12(ptr %0, float %1, float %2, %Vec3 %3) {
entry:
  %p = alloca %Vec3, align 8
  store %Vec3 %3, ptr %p, align 4
  %4 = getelementptr inbounds %DiffuseLight, ptr %0, i32 0, i32 0
  %readtmp = load %Texture, ptr %4, align 8
  %calltmp = call %Color @value_0.6(%Texture %readtmp, float %1, float %2, ptr %p)
  ret %Color %calltmp
}

define %Quad @new_0.13(%Vec3 %0, %Vec3 %1, %Vec3 %2, ptr %3) {
entry:
  %result = alloca %Quad, align 8
  %4 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 4
  store ptr %3, ptr %4, align 8
  %5 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 2
  store %Vec3 %2, ptr %5, align 4
  %6 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 1
  store %Vec3 %1, ptr %6, align 4
  %7 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 0
  store %Vec3 %0, ptr %7, align 4
  %8 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 1
  %readtmp = load %Vec3, ptr %8, align 4
  %9 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 2
  %readtmp1 = load %Vec3, ptr %9, align 4
  %calltmp = call %Vec3 @cross_0(%Vec3 %readtmp, %Vec3 %readtmp1)
  %10 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 5
  %calltmp2 = call %Vec3 @normal_0(%Vec3 %calltmp)
  store %Vec3 %calltmp2, ptr %10, align 4
  %11 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 3
  %calltmp3 = call float @dot_0(%Vec3 %calltmp, %Vec3 %calltmp)
  %calltmp4 = call %Vec3 @div_0(%Vec3 %calltmp, float %calltmp3)
  store %Vec3 %calltmp4, ptr %11, align 4
  %12 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 7
  %13 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 0
  %readtmp5 = load %Vec3, ptr %13, align 4
  %14 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 0
  %readtmp6 = load %Vec3, ptr %14, align 4
  %15 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 1
  %readtmp7 = load %Vec3, ptr %15, align 4
  %calltmp8 = call %Vec3 @add_0(%Vec3 %readtmp6, %Vec3 %readtmp7)
  %16 = getelementptr inbounds %Quad, ptr %result, i32 0, i32 2
  %readtmp9 = load %Vec3, ptr %16, align 4
  %calltmp10 = call %Vec3 @add_0(%Vec3 %calltmp8, %Vec3 %readtmp9)
  %calltmp11 = call %AABB @newV_0(%Vec3 %readtmp5, %Vec3 %calltmp10)
  %calltmp12 = call %AABB @pad_0(%AABB %calltmp11)
  store %AABB %calltmp12, ptr %12, align 4
  %readtmp13 = load %Quad, ptr %result, align 8
  ret %Quad %readtmp13
}

define %AABB @newV_0(%Vec3 %0, %Vec3 %1) {
entry:
  %result = alloca %AABB, align 8
  %2 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 0
  %extracted = extractvalue %Vec3 %1, 0
  %extracted1 = extractvalue %Vec3 %0, 0
  %calltmp = call float @fminf(float %extracted, float %extracted1)
  %extracted2 = extractvalue %Vec3 %1, 0
  %extracted3 = extractvalue %Vec3 %0, 0
  %calltmp4 = call float @fmaxf(float %extracted2, float %extracted3)
  %calltmp5 = call %Interval @new_0.14(float %calltmp, float %calltmp4)
  store %Interval %calltmp5, ptr %2, align 4
  %3 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 1
  %extracted6 = extractvalue %Vec3 %1, 1
  %extracted7 = extractvalue %Vec3 %0, 1
  %calltmp8 = call float @fminf(float %extracted6, float %extracted7)
  %extracted9 = extractvalue %Vec3 %1, 1
  %extracted10 = extractvalue %Vec3 %0, 1
  %calltmp11 = call float @fmaxf(float %extracted9, float %extracted10)
  %calltmp12 = call %Interval @new_0.14(float %calltmp8, float %calltmp11)
  store %Interval %calltmp12, ptr %3, align 4
  %4 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 2
  %extracted13 = extractvalue %Vec3 %1, 2
  %extracted14 = extractvalue %Vec3 %0, 2
  %calltmp15 = call float @fminf(float %extracted13, float %extracted14)
  %extracted16 = extractvalue %Vec3 %1, 2
  %extracted17 = extractvalue %Vec3 %0, 2
  %calltmp18 = call float @fmaxf(float %extracted16, float %extracted17)
  %calltmp19 = call %Interval @new_0.14(float %calltmp15, float %calltmp18)
  store %Interval %calltmp19, ptr %4, align 4
  %readtmp = load %AABB, ptr %result, align 4
  ret %AABB %readtmp
}

declare float @fminf(float, float)

declare float @fmaxf(float, float)

define %Interval @new_0.14(float %0, float %1) {
entry:
  %result = alloca %Interval, align 8
  %2 = getelementptr inbounds %Interval, ptr %result, i32 0, i32 1
  store float %1, ptr %2, align 4
  %3 = getelementptr inbounds %Interval, ptr %result, i32 0, i32 0
  store float %0, ptr %3, align 4
  %readtmp = load %Interval, ptr %result, align 4
  ret %Interval %readtmp
}

define %AABB @pad_0(%AABB %0) {
entry:
  %result = alloca %AABB, align 8
  store %AABB %0, ptr %result, align 4
  %extracted = extractvalue %AABB %0, 0
  %calltmp = call float @size_0(%Interval %extracted)
  %lttmp = fcmp ule float %calltmp, 0x3F847AE140000000
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %1 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 0
  %extracted1 = extractvalue %AABB %0, 0
  %calltmp2 = call %Interval @expand_0(%Interval %extracted1, float 0x3F847AE140000000)
  store %Interval %calltmp2, ptr %1, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %extracted3 = extractvalue %AABB %0, 1
  %calltmp4 = call float @size_0(%Interval %extracted3)
  %lttmp5 = fcmp ule float %calltmp4, 0x3F847AE140000000
  %ifcond6 = icmp ne i1 %lttmp5, false
  br i1 %ifcond6, label %ifbody7, label %ifmerge8

ifbody7:                                          ; preds = %ifmerge
  %2 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 1
  %extracted9 = extractvalue %AABB %0, 1
  %calltmp10 = call %Interval @expand_0(%Interval %extracted9, float 0x3F847AE140000000)
  store %Interval %calltmp10, ptr %2, align 4
  br label %ifmerge8

ifmerge8:                                         ; preds = %ifbody7, %ifmerge
  %extracted11 = extractvalue %AABB %0, 2
  %calltmp12 = call float @size_0(%Interval %extracted11)
  %lttmp13 = fcmp ule float %calltmp12, 0x3F847AE140000000
  %ifcond14 = icmp ne i1 %lttmp13, false
  br i1 %ifcond14, label %ifbody15, label %ifmerge16

ifbody15:                                         ; preds = %ifmerge8
  %3 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 2
  %extracted17 = extractvalue %AABB %0, 2
  %calltmp18 = call %Interval @expand_0(%Interval %extracted17, float 0x3F847AE140000000)
  store %Interval %calltmp18, ptr %3, align 4
  br label %ifmerge16

ifmerge16:                                        ; preds = %ifbody15, %ifmerge8
  %readtmp = load %AABB, ptr %result, align 4
  ret %AABB %readtmp
}

define float @size_0(%Interval %0) {
entry:
  %extracted = extractvalue %Interval %0, 1
  %extracted1 = extractvalue %Interval %0, 0
  %subtmp = fsub float %extracted, %extracted1
  ret float %subtmp
}

define %Interval @expand_0(%Interval %0, float %1) {
entry:
  %divtmp = fdiv float %1, 2.000000e+00
  %extracted = extractvalue %Interval %0, 0
  %subtmp = fsub float %extracted, %divtmp
  %extracted1 = extractvalue %Interval %0, 1
  %addtmp = fadd float %extracted1, %divtmp
  %calltmp = call %Interval @new_0.14(float %subtmp, float %addtmp)
  ret %Interval %calltmp
}

define %Hittable @new_0.15(ptr %0, %Vec3 %1) {
entry:
  %result = alloca %Hittable, align 8
  %readtmp = load %Quad, ptr %0, align 8
  %2 = getelementptr inbounds %Hittable, ptr %result, i32 0, i32 0
  store %Vec3 %1, ptr %2, align 4
  %3 = getelementptr inbounds %Hittable, ptr %result, i32 0, i32 1
  %calltmp = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  store %Vec3 %calltmp, ptr %3, align 4
  %4 = getelementptr inbounds %Hittable, ptr %result, i32 0, i32 2
  %5 = getelementptr inbounds %HittableVTable, ptr %4, i32 0, i32 0
  store ptr @checkHit_0, ptr %5, align 8
  %6 = getelementptr inbounds %Hittable, ptr %result, i32 0, i32 2
  %7 = getelementptr inbounds %HittableVTable, ptr %6, i32 0, i32 1
  store ptr @boundingBox_0, ptr %7, align 8
  %8 = getelementptr inbounds %Hittable, ptr %result, i32 0, i32 3
  store ptr %0, ptr %8, align 8
  %readtmp1 = load %Hittable, ptr %result, align 8
  ret %Hittable %readtmp1
}

define i1 @checkHit_0(ptr %0, %HRay %1, %Vec3 %2, %Interval %3, ptr %4) {
entry:
  %5 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 5
  %readtmp = load %Vec3, ptr %5, align 4
  %extracted = extractvalue %HRay %1, 1
  %calltmp = call float @dot_0(%Vec3 %readtmp, %Vec3 %extracted)
  %calltmp1 = call float @fabsf(float %calltmp)
  %lttmp = fcmp ule float %calltmp1, 0x3EB0C6F7A0000000
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  ret i1 false

ifmerge:                                          ; preds = %entry
  %6 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 6
  %7 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 5
  %readtmp2 = load %Vec3, ptr %7, align 4
  %8 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 0
  %readtmp3 = load %Vec3, ptr %8, align 4
  %calltmp4 = call %Vec3 @add_0(%Vec3 %readtmp3, %Vec3 %2)
  %calltmp5 = call float @dot_0(%Vec3 %readtmp2, %Vec3 %calltmp4)
  store float %calltmp5, ptr %6, align 4
  %9 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 6
  %readtmp6 = load float, ptr %9, align 4
  %10 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 5
  %readtmp7 = load %Vec3, ptr %10, align 4
  %extracted8 = extractvalue %HRay %1, 0
  %calltmp9 = call float @dot_0(%Vec3 %readtmp7, %Vec3 %extracted8)
  %subtmp = fsub float %readtmp6, %calltmp9
  %divtmp = fdiv float %subtmp, %calltmp
  %calltmp10 = call i1 @contains_0(%Interval %3, float %divtmp)
  %nottmp = xor i1 %calltmp10, true
  %ifcond11 = icmp ne i1 %nottmp, false
  br i1 %ifcond11, label %ifbody12, label %ifmerge13

ifbody12:                                         ; preds = %ifmerge
  ret i1 false

ifmerge13:                                        ; preds = %ifmerge
  %extracted14 = extractvalue %HRay %1, 0
  %extracted15 = extractvalue %HRay %1, 1
  %calltmp16 = call %Vec3 @mul_0(%Vec3 %extracted15, float %divtmp)
  %calltmp17 = call %Vec3 @add_0(%Vec3 %extracted14, %Vec3 %calltmp16)
  %11 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 0
  %readtmp18 = load %Vec3, ptr %11, align 4
  %calltmp19 = call %Vec3 @add_0(%Vec3 %readtmp18, %Vec3 %2)
  %calltmp20 = call %Vec3 @sub_0(%Vec3 %calltmp17, %Vec3 %calltmp19)
  %12 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 3
  %readtmp21 = load %Vec3, ptr %12, align 4
  %13 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 2
  %readtmp22 = load %Vec3, ptr %13, align 4
  %calltmp23 = call %Vec3 @cross_0(%Vec3 %calltmp20, %Vec3 %readtmp22)
  %calltmp24 = call float @dot_0(%Vec3 %readtmp21, %Vec3 %calltmp23)
  %14 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 3
  %readtmp25 = load %Vec3, ptr %14, align 4
  %15 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 1
  %readtmp26 = load %Vec3, ptr %15, align 4
  %calltmp27 = call %Vec3 @cross_0(%Vec3 %readtmp26, %Vec3 %calltmp20)
  %calltmp28 = call float @dot_0(%Vec3 %readtmp25, %Vec3 %calltmp27)
  %calltmp29 = call i1 @is_interior_0(float %calltmp24, float %calltmp28, ptr %4)
  %nottmp30 = xor i1 %calltmp29, true
  %ifcond31 = icmp ne i1 %nottmp30, false
  br i1 %ifcond31, label %ifbody32, label %ifmerge33

ifbody32:                                         ; preds = %ifmerge13
  ret i1 false

ifmerge33:                                        ; preds = %ifmerge13
  %16 = getelementptr inbounds %HitRecord, ptr %4, i32 0, i32 2
  store float %divtmp, ptr %16, align 4
  %17 = getelementptr inbounds %HitRecord, ptr %4, i32 0, i32 0
  store %Vec3 %calltmp17, ptr %17, align 4
  %18 = getelementptr inbounds %HitRecord, ptr %4, i32 0, i32 6
  %19 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 4
  %readtmp34 = load ptr, ptr %19, align 8
  store ptr %readtmp34, ptr %18, align 8
  %extracted35 = extractvalue %HRay %1, 1
  %20 = getelementptr inbounds %Quad, ptr %0, i32 0, i32 5
  %readtmp36 = load %Vec3, ptr %20, align 4
  %calltmp37 = call void @set_face_normal_0(ptr %4, %Vec3 %extracted35, %Vec3 %readtmp36)
  ret i1 true
}

define i1 @contains_0(%Interval %0, float %1) {
entry:
  %extracted = extractvalue %Interval %0, 0
  %gttmp = fcmp uge float %extracted, %1
  %extracted1 = extractvalue %Interval %0, 1
  %lttmp = fcmp ule float %extracted1, %1
  %ortmp = or i1 %gttmp, %lttmp
  %nottmp = xor i1 %ortmp, true
  ret i1 %nottmp
}

define i1 @is_interior_0(float %0, float %1, ptr %2) {
entry:
  %lttmp = fcmp ule float %0, 0.000000e+00
  %gttmp = fcmp uge float %0, 1.000000e+00
  %ortmp = or i1 %lttmp, %gttmp
  %lttmp1 = fcmp ule float %1, 0.000000e+00
  %ortmp2 = or i1 %ortmp, %lttmp1
  %gttmp3 = fcmp uge float %1, 1.000000e+00
  %ortmp4 = or i1 %ortmp2, %gttmp3
  %ifcond = icmp ne i1 %ortmp4, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  ret i1 false

ifmerge:                                          ; preds = %entry
  %3 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 3
  store float %0, ptr %3, align 4
  %4 = getelementptr inbounds %HitRecord, ptr %2, i32 0, i32 4
  store float %1, ptr %4, align 4
  ret i1 true
}

define void @set_face_normal_0(ptr %0, %Vec3 %1, %Vec3 %2) {
entry:
  %3 = getelementptr inbounds %HitRecord, ptr %0, i32 0, i32 5
  %calltmp = call float @dot_0(%Vec3 %1, %Vec3 %2)
  %lttmp = fcmp ule float %calltmp, 0.000000e+00
  store i1 %lttmp, ptr %3, align 1
  %4 = getelementptr inbounds %HitRecord, ptr %0, i32 0, i32 1
  store %Vec3 %2, ptr %4, align 4
  %5 = getelementptr inbounds %HitRecord, ptr %0, i32 0, i32 5
  %readtmp = load i1, ptr %5, align 1
  %nottmp = xor i1 %readtmp, true
  %ifcond = icmp ne i1 %nottmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %6 = getelementptr inbounds %HitRecord, ptr %0, i32 0, i32 1
  %calltmp1 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %7 = getelementptr inbounds %HitRecord, ptr %0, i32 0, i32 1
  %readtmp2 = load %Vec3, ptr %7, align 4
  %calltmp3 = call %Vec3 @sub_0(%Vec3 %calltmp1, %Vec3 %readtmp2)
  store %Vec3 %calltmp3, ptr %6, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  ret void
}

define %AABB @boundingBox_0(ptr %0) {
entry:
  %readtmp = load %Quad, ptr %0, align 8
  %extracted = extractvalue %Quad %readtmp, 7
  ret %AABB %extracted
}

define void @append_0(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

declare ptr @realloc(ptr, i32)

define void @append_0.16(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.17(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.17(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define void @append_0.18(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.19(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.19(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define void @append_0.20(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.21(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.21(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define void @append_0.22(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.23(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.23(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define void @append_0.24(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.25(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.25(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define void @create_box_0(ptr %0, %Vec3 %1, %Vec3 %2, ptr %3) {
entry:
  %calltmp = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x %Group], ptr null, i32 1) to i32))
  %calltmp1 = call %Group @new_0.26()
  store %Group %calltmp1, ptr %calltmp, align 8
  %extracted = extractvalue %Vec3 %1, 0
  %extracted2 = extractvalue %Vec3 %2, 0
  %calltmp3 = call float @fminf(float %extracted, float %extracted2)
  %extracted4 = extractvalue %Vec3 %1, 1
  %extracted5 = extractvalue %Vec3 %2, 1
  %calltmp6 = call float @fminf(float %extracted4, float %extracted5)
  %extracted7 = extractvalue %Vec3 %1, 2
  %extracted8 = extractvalue %Vec3 %2, 2
  %calltmp9 = call float @fminf(float %extracted7, float %extracted8)
  %calltmp10 = call %Vec3 @new_0(float %calltmp3, float %calltmp6, float %calltmp9)
  %extracted11 = extractvalue %Vec3 %1, 0
  %extracted12 = extractvalue %Vec3 %2, 0
  %calltmp13 = call float @fmaxf(float %extracted11, float %extracted12)
  %extracted14 = extractvalue %Vec3 %1, 1
  %extracted15 = extractvalue %Vec3 %2, 1
  %calltmp16 = call float @fmaxf(float %extracted14, float %extracted15)
  %extracted17 = extractvalue %Vec3 %1, 2
  %extracted18 = extractvalue %Vec3 %2, 2
  %calltmp19 = call float @fmaxf(float %extracted17, float %extracted18)
  %calltmp20 = call %Vec3 @new_0(float %calltmp13, float %calltmp16, float %calltmp19)
  %extracted21 = extractvalue %Vec3 %calltmp20, 0
  %extracted22 = extractvalue %Vec3 %calltmp10, 0
  %subtmp = fsub float %extracted21, %extracted22
  %calltmp23 = call %Vec3 @new_0(float %subtmp, float 0.000000e+00, float 0.000000e+00)
  %extracted24 = extractvalue %Vec3 %calltmp20, 1
  %extracted25 = extractvalue %Vec3 %calltmp10, 1
  %subtmp26 = fsub float %extracted24, %extracted25
  %calltmp27 = call %Vec3 @new_0(float 0.000000e+00, float %subtmp26, float 0.000000e+00)
  %extracted28 = extractvalue %Vec3 %calltmp20, 2
  %extracted29 = extractvalue %Vec3 %calltmp10, 2
  %subtmp30 = fsub float %extracted28, %extracted29
  %calltmp31 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float %subtmp30)
  %calltmp32 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x [6 x %Quad]], ptr null, i32 1) to i32))
  %elemtemp = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 0
  %extracted33 = extractvalue %Vec3 %calltmp10, 0
  %extracted34 = extractvalue %Vec3 %calltmp10, 1
  %extracted35 = extractvalue %Vec3 %calltmp20, 2
  %calltmp36 = call %Vec3 @new_0(float %extracted33, float %extracted34, float %extracted35)
  %calltmp37 = call %Quad @new_0.13(%Vec3 %calltmp36, %Vec3 %calltmp23, %Vec3 %calltmp27, ptr %3)
  store %Quad %calltmp37, ptr %elemtemp, align 8
  %elemtemp38 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 1
  %extracted39 = extractvalue %Vec3 %calltmp20, 0
  %extracted40 = extractvalue %Vec3 %calltmp10, 1
  %extracted41 = extractvalue %Vec3 %calltmp20, 2
  %calltmp42 = call %Vec3 @new_0(float %extracted39, float %extracted40, float %extracted41)
  %calltmp43 = call %Vec3 @neg_0.28(%Vec3 %calltmp31)
  %calltmp44 = call %Quad @new_0.13(%Vec3 %calltmp42, %Vec3 %calltmp43, %Vec3 %calltmp27, ptr %3)
  store %Quad %calltmp44, ptr %elemtemp38, align 8
  %elemtemp45 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 2
  %extracted46 = extractvalue %Vec3 %calltmp20, 0
  %extracted47 = extractvalue %Vec3 %calltmp10, 1
  %extracted48 = extractvalue %Vec3 %calltmp10, 2
  %calltmp49 = call %Vec3 @new_0(float %extracted46, float %extracted47, float %extracted48)
  %calltmp50 = call %Vec3 @neg_0.28(%Vec3 %calltmp23)
  %calltmp51 = call %Quad @new_0.13(%Vec3 %calltmp49, %Vec3 %calltmp50, %Vec3 %calltmp27, ptr %3)
  store %Quad %calltmp51, ptr %elemtemp45, align 8
  %elemtemp52 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 3
  %extracted53 = extractvalue %Vec3 %calltmp10, 0
  %extracted54 = extractvalue %Vec3 %calltmp10, 1
  %extracted55 = extractvalue %Vec3 %calltmp10, 2
  %calltmp56 = call %Vec3 @new_0(float %extracted53, float %extracted54, float %extracted55)
  %calltmp57 = call %Quad @new_0.13(%Vec3 %calltmp56, %Vec3 %calltmp31, %Vec3 %calltmp27, ptr %3)
  store %Quad %calltmp57, ptr %elemtemp52, align 8
  %elemtemp58 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 4
  %extracted59 = extractvalue %Vec3 %calltmp10, 0
  %extracted60 = extractvalue %Vec3 %calltmp20, 1
  %extracted61 = extractvalue %Vec3 %calltmp20, 2
  %calltmp62 = call %Vec3 @new_0(float %extracted59, float %extracted60, float %extracted61)
  %calltmp63 = call %Vec3 @neg_0.28(%Vec3 %calltmp31)
  %calltmp64 = call %Quad @new_0.13(%Vec3 %calltmp62, %Vec3 %calltmp23, %Vec3 %calltmp63, ptr %3)
  store %Quad %calltmp64, ptr %elemtemp58, align 8
  %elemtemp65 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 5
  %extracted66 = extractvalue %Vec3 %calltmp10, 0
  %extracted67 = extractvalue %Vec3 %calltmp10, 1
  %extracted68 = extractvalue %Vec3 %calltmp10, 2
  %calltmp69 = call %Vec3 @new_0(float %extracted66, float %extracted67, float %extracted68)
  %calltmp70 = call %Quad @new_0.13(%Vec3 %calltmp69, %Vec3 %calltmp23, %Vec3 %calltmp31, ptr %3)
  store %Quad %calltmp70, ptr %elemtemp65, align 8
  %elemtemp71 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 0
  %calltmp72 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp73 = call %Hittable @new_0.15(ptr %elemtemp71, %Vec3 %calltmp72)
  %calltmp74 = call void @append_0.29(ptr %0, %Hittable %calltmp73)
  %elemtemp75 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 1
  %calltmp76 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp77 = call %Hittable @new_0.15(ptr %elemtemp75, %Vec3 %calltmp76)
  %calltmp78 = call void @append_0.31(ptr %0, %Hittable %calltmp77)
  %elemtemp79 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 2
  %calltmp80 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp81 = call %Hittable @new_0.15(ptr %elemtemp79, %Vec3 %calltmp80)
  %calltmp82 = call void @append_0.33(ptr %0, %Hittable %calltmp81)
  %elemtemp83 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 3
  %calltmp84 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp85 = call %Hittable @new_0.15(ptr %elemtemp83, %Vec3 %calltmp84)
  %calltmp86 = call void @append_0.35(ptr %0, %Hittable %calltmp85)
  %elemtemp87 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 4
  %calltmp88 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp89 = call %Hittable @new_0.15(ptr %elemtemp87, %Vec3 %calltmp88)
  %calltmp90 = call void @append_0.37(ptr %0, %Hittable %calltmp89)
  %elemtemp91 = getelementptr inbounds [6 x %Quad], ptr %calltmp32, i32 0, i32 5
  %calltmp92 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp93 = call %Hittable @new_0.15(ptr %elemtemp91, %Vec3 %calltmp92)
  %calltmp94 = call void @append_0.39(ptr %0, %Hittable %calltmp93)
  ret void
}

define %Group @new_0.26() {
entry:
  %result = alloca %Group, align 8
  %0 = getelementptr inbounds %Group, ptr %result, i32 0, i32 0
  %calltmp = call %ArrayList.15 @init_0.27()
  store %ArrayList.15 %calltmp, ptr %0, align 8
  %readtmp = load %Group, ptr %result, align 8
  ret %Group %readtmp
}

define %ArrayList.15 @init_0.27() {
entry:
  %result = alloca %ArrayList.15, align 8
  %0 = getelementptr inbounds %ArrayList.15, ptr %result, i32 0, i32 1
  store i32 0, ptr %0, align 4
  %1 = getelementptr inbounds %ArrayList.15, ptr %result, i32 0, i32 0
  store i32 0, ptr %1, align 4
  %2 = getelementptr inbounds %ArrayList.15, ptr %result, i32 0, i32 2
  store ptr null, ptr %2, align 8
  %readtmp = load %ArrayList.15, ptr %result, align 8
  ret %ArrayList.15 %readtmp
}

define %Vec3 @neg_0.28(%Vec3 %0) {
entry:
  %extracted = extractvalue %Vec3 %0, 0
  %subtmp = fsub float 0.000000e+00, %extracted
  %extracted1 = extractvalue %Vec3 %0, 1
  %subtmp2 = fsub float 0.000000e+00, %extracted1
  %extracted3 = extractvalue %Vec3 %0, 2
  %subtmp4 = fsub float 0.000000e+00, %extracted3
  %calltmp = call %Vec3 @new_0(float %subtmp, float %subtmp2, float %subtmp4)
  ret %Vec3 %calltmp
}

define void @append_0.29(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.30(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.30(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define void @append_0.31(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.32(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.32(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define void @append_0.33(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.34(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.34(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define void @append_0.35(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.36(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.36(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define void @append_0.37(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.38(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.38(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define void @append_0.39(ptr %0, %Hittable %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %addtmp = add i32 %readtmp1, 1
  %lttmp = icmp ult i32 %readtmp, %addtmp
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call void @extend_0.40(ptr %0)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp2 to i64
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp3 = load i32, ptr %5, align 4
  %multmp = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %tmp_float = zext i32 %multmp to i64
  %addtmp4 = add i64 %tmp_int, %tmp_float
  %tmp_pointer = inttoptr i64 %addtmp4 to ptr
  store %Hittable %1, ptr %tmp_pointer, align 8
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp5 = load i32, ptr %6, align 4
  %addtmp6 = add i32 %readtmp5, 1
  store i32 %addtmp6, ptr %6, align 4
  ret void
}

define void @extend_0.40(ptr %0) {
entry:
  %1 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp = load i32, ptr %2, align 4
  %multmp = mul i32 %readtmp, 2
  store i32 %multmp, ptr %1, align 4
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp1 = load i32, ptr %3, align 4
  %neqtmp = icmp eq i32 0, %readtmp1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  store i32 1, ptr %4, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %5 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %6 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp2 = load ptr, ptr %6, align 8
  %7 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 0
  %readtmp3 = load i32, ptr %7, align 4
  %multmp4 = mul i32 %readtmp3, ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %calltmp = call ptr @realloc(ptr %readtmp2, i32 %multmp4)
  store ptr %calltmp, ptr %5, align 8
  ret void
}

define %BHV @new_0.41(ptr %0, i32 %1, i32 %2) {
entry:
  %result = alloca %BHV, align 8
  %subtmp = sub i32 %2, %1
  %neqtmp = icmp eq i32 1, %subtmp
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %BHV, ptr %result, i32 0, i32 0
  %calltmp = call %Hittable @get_0(ptr %0, i32 %1)
  store %Hittable %calltmp, ptr %3, align 8
  %4 = getelementptr inbounds %BHV, ptr %result, i32 0, i32 1
  %calltmp1 = call %Hittable @get_0.42(ptr %0, i32 %1)
  store %Hittable %calltmp1, ptr %4, align 8
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %neqtmp2 = icmp eq i32 2, %subtmp
  %ifcond3 = icmp ne i1 %neqtmp2, false
  br i1 %ifcond3, label %ifbody4, label %ifmerge5

ifbody4:                                          ; preds = %ifmerge
  %5 = getelementptr inbounds %BHV, ptr %result, i32 0, i32 0
  %calltmp6 = call %Hittable @get_0.44(ptr %0, i32 %1)
  store %Hittable %calltmp6, ptr %5, align 8
  %6 = getelementptr inbounds %BHV, ptr %result, i32 0, i32 1
  %addtmp = add i32 %1, 1
  %calltmp7 = call %Hittable @get_0.46(ptr %0, i32 %addtmp)
  store %Hittable %calltmp7, ptr %6, align 8
  br label %ifmerge5

ifmerge5:                                         ; preds = %ifbody4, %ifmerge
  %gttmp = icmp ugt i32 %subtmp, 2
  %ifcond8 = icmp ne i1 %gttmp, false
  br i1 %ifcond8, label %ifbody9, label %ifmerge10

ifbody9:                                          ; preds = %ifmerge5
  %subtmp11 = sub i32 %2, 1
  %calltmp12 = call void @qsort_0(ptr %0, i32 %1, i32 %subtmp11, i32 0)
  %calltmp13 = call ptr @malloc(i32 ptrtoint (ptr getelementptr inbounds ([1 x [2 x %BHV]], ptr null, i32 1) to i32))
  %divtmp = udiv i32 %subtmp, 2
  %addtmp14 = add i32 %1, %divtmp
  %elemtemp = getelementptr inbounds [2 x %BHV], ptr %calltmp13, i32 0, i32 0
  %calltmp15 = call %BHV @new_0.41(ptr %0, i32 %1, i32 %addtmp14)
  store %BHV %calltmp15, ptr %elemtemp, align 8
  %elemtemp16 = getelementptr inbounds [2 x %BHV], ptr %calltmp13, i32 0, i32 1
  %calltmp17 = call %BHV @new_0.41(ptr %0, i32 %addtmp14, i32 %2)
  store %BHV %calltmp17, ptr %elemtemp16, align 8
  %7 = getelementptr inbounds %BHV, ptr %result, i32 0, i32 0
  %elemtemp18 = getelementptr inbounds [2 x %BHV], ptr %calltmp13, i32 0, i32 0
  %calltmp19 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp20 = call %Hittable @new_1.61(ptr %elemtemp18, %Vec3 %calltmp19)
  store %Hittable %calltmp20, ptr %7, align 8
  %8 = getelementptr inbounds %BHV, ptr %result, i32 0, i32 1
  %elemtemp21 = getelementptr inbounds [2 x %BHV], ptr %calltmp13, i32 0, i32 1
  %calltmp22 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %calltmp23 = call %Hittable @new_1.61(ptr %elemtemp21, %Vec3 %calltmp22)
  store %Hittable %calltmp23, ptr %8, align 8
  br label %ifmerge10

ifmerge10:                                        ; preds = %ifbody9, %ifmerge5
  %9 = getelementptr inbounds %BHV, ptr %result, i32 0, i32 2
  %10 = getelementptr inbounds %BHV, ptr %result, i32 0, i32 0
  %readtmp = load %Hittable, ptr %10, align 8
  %calltmp24 = call %AABB @boundingBox_0.50(%Hittable %readtmp)
  %11 = getelementptr inbounds %BHV, ptr %result, i32 0, i32 1
  %readtmp25 = load %Hittable, ptr %11, align 8
  %calltmp26 = call %AABB @boundingBox_0.50(%Hittable %readtmp25)
  %calltmp27 = call %AABB @combine_0(%AABB %calltmp24, %AABB %calltmp26)
  store %AABB %calltmp27, ptr %9, align 4
  %readtmp28 = load %BHV, ptr %result, align 8
  ret %BHV %readtmp28
}

define %Hittable @get_0(ptr %0, i32 %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp = load i32, ptr %2, align 4
  %subtmp = sub i32 %readtmp, 1
  %gttmp = icmp ugt i32 %1, %subtmp
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %tmp_float = zext i32 %readtmp1 to i64
  %calltmp = call void @printint(i64 %tmp_float)
  %calltmp2 = call void @printstr(ptr @str)
  %calltmp3 = call void @exit(i32 1)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp4 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp4 to i64
  %tmp_float5 = zext i32 %1 to i64
  %multmp = mul i64 %tmp_float5, i32 ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %addtmp = add i64 %tmp_int, %multmp
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  %readtmp6 = load %Hittable, ptr %tmp_pointer, align 8
  ret %Hittable %readtmp6
}

declare void @printint(i64)

declare void @printstr(ptr)

declare void @exit(i32)

define %Hittable @get_0.42(ptr %0, i32 %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp = load i32, ptr %2, align 4
  %subtmp = sub i32 %readtmp, 1
  %gttmp = icmp ugt i32 %1, %subtmp
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %tmp_float = zext i32 %readtmp1 to i64
  %calltmp = call void @printint(i64 %tmp_float)
  %calltmp2 = call void @printstr(ptr @str.43)
  %calltmp3 = call void @exit(i32 1)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp4 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp4 to i64
  %tmp_float5 = zext i32 %1 to i64
  %multmp = mul i64 %tmp_float5, i32 ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %addtmp = add i64 %tmp_int, %multmp
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  %readtmp6 = load %Hittable, ptr %tmp_pointer, align 8
  ret %Hittable %readtmp6
}

define %Hittable @get_0.44(ptr %0, i32 %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp = load i32, ptr %2, align 4
  %subtmp = sub i32 %readtmp, 1
  %gttmp = icmp ugt i32 %1, %subtmp
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %tmp_float = zext i32 %readtmp1 to i64
  %calltmp = call void @printint(i64 %tmp_float)
  %calltmp2 = call void @printstr(ptr @str.45)
  %calltmp3 = call void @exit(i32 1)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp4 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp4 to i64
  %tmp_float5 = zext i32 %1 to i64
  %multmp = mul i64 %tmp_float5, i32 ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %addtmp = add i64 %tmp_int, %multmp
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  %readtmp6 = load %Hittable, ptr %tmp_pointer, align 8
  ret %Hittable %readtmp6
}

define %Hittable @get_0.46(ptr %0, i32 %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp = load i32, ptr %2, align 4
  %subtmp = sub i32 %readtmp, 1
  %gttmp = icmp ugt i32 %1, %subtmp
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %tmp_float = zext i32 %readtmp1 to i64
  %calltmp = call void @printint(i64 %tmp_float)
  %calltmp2 = call void @printstr(ptr @str.47)
  %calltmp3 = call void @exit(i32 1)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp4 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp4 to i64
  %tmp_float5 = zext i32 %1 to i64
  %multmp = mul i64 %tmp_float5, i32 ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %addtmp = add i64 %tmp_int, %multmp
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  %readtmp6 = load %Hittable, ptr %tmp_pointer, align 8
  ret %Hittable %readtmp6
}

define void @qsort_0(ptr %0, i32 %1, i32 %2, i32 %3) {
entry:
  %lttmp = icmp ult i32 %1, %2
  %ifcond = icmp ne i1 %lttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call i32 @partition_0(ptr %0, i32 %1, i32 %2, i32 %3)
  %subtmp = sub i32 %calltmp, 1
  %calltmp1 = call void @qsort_0(ptr %0, i32 %1, i32 %subtmp, i32 %3)
  %addtmp = add i32 %calltmp, 1
  %calltmp2 = call void @qsort_0(ptr %0, i32 %addtmp, i32 %2, i32 %3)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  ret void
}

define i32 @partition_0(ptr %0, i32 %1, i32 %2, i32 %3) {
entry:
  %piviot = alloca float, align 4
  %i = alloca i32, align 4
  %calltmp = call %Hittable @get_0.48(ptr %0, i32 %2)
  %calltmp1 = call %AABB @boundingBox_0.50(%Hittable %calltmp)
  %calltmp2 = call %Interval @axis_0(%AABB %calltmp1, i32 %3)
  %extracted = extractvalue %Interval %calltmp2, 0
  store float %extracted, ptr %piviot, align 4
  %subtmp = sub i32 %1, 1
  store i32 %subtmp, ptr %i, align 4
  %tmp = alloca %Hittable, align 8
  %j = alloca i32, align 4
  store i32 %1, ptr %j, align 4
  br label %whilehead

whilehead:                                        ; preds = %ifmerge, %entry
  %readtmp = load i32, ptr %j, align 4
  %lttmp = icmp ult i32 %readtmp, %2
  %docond = icmp ne i1 %lttmp, false
  br i1 %docond, label %whilebody, label %whilemerge

whilebody:                                        ; preds = %whilehead
  %readtmp3 = load i32, ptr %j, align 4
  %calltmp4 = call %Hittable @get_0.52(ptr %0, i32 %readtmp3)
  %calltmp5 = call %AABB @boundingBox_0.50(%Hittable %calltmp4)
  %calltmp6 = call %Interval @axis_0(%AABB %calltmp5, i32 %3)
  %extracted7 = extractvalue %Interval %calltmp6, 0
  %lttmp8 = fcmp ule float %extracted7, ptr %piviot
  %ifcond = icmp ne i1 %lttmp8, false
  br i1 %ifcond, label %ifbody, label %ifmerge

whilemerge:                                       ; preds = %whilehead
  %readtmp19 = load i32, ptr %i, align 4
  %addtmp20 = add i32 %readtmp19, 1
  %calltmp21 = call ptr @getPtr_0.57(ptr %0, i32 %addtmp20)
  %calltmp22 = call ptr @getPtr_0.59(ptr %0, i32 %2)
  %readtmp23 = load %Hittable, ptr %calltmp21, align 8
  store %Hittable %readtmp23, ptr %tmp, align 8
  %readtmp24 = load %Hittable, ptr %calltmp22, align 8
  store %Hittable %readtmp24, ptr %calltmp21, align 8
  %readtmp25 = load %Hittable, ptr %tmp, align 8
  store %Hittable %readtmp25, ptr %calltmp22, align 8
  %readtmp26 = load i32, ptr %i, align 4
  %addtmp27 = add i32 %readtmp26, 1
  ret i32 %addtmp27

ifbody:                                           ; preds = %whilebody
  %readtmp9 = load i32, ptr %i, align 4
  %addtmp = add i32 %readtmp9, 1
  store i32 %addtmp, ptr %i, align 4
  %readtmp10 = load i32, ptr %j, align 4
  %calltmp11 = call ptr @getPtr_0(ptr %0, i32 %readtmp10)
  %readtmp12 = load i32, ptr %i, align 4
  %calltmp13 = call ptr @getPtr_0.55(ptr %0, i32 %readtmp12)
  %readtmp14 = load %Hittable, ptr %calltmp11, align 8
  store %Hittable %readtmp14, ptr %tmp, align 8
  %readtmp15 = load %Hittable, ptr %calltmp13, align 8
  store %Hittable %readtmp15, ptr %calltmp11, align 8
  %readtmp16 = load %Hittable, ptr %tmp, align 8
  store %Hittable %readtmp16, ptr %calltmp13, align 8
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %whilebody
  %readtmp17 = load i32, ptr %j, align 4
  %addtmp18 = add i32 %readtmp17, 1
  store i32 %addtmp18, ptr %j, align 4
  br label %whilehead
}

define %Hittable @get_0.48(ptr %0, i32 %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp = load i32, ptr %2, align 4
  %subtmp = sub i32 %readtmp, 1
  %gttmp = icmp ugt i32 %1, %subtmp
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %tmp_float = zext i32 %readtmp1 to i64
  %calltmp = call void @printint(i64 %tmp_float)
  %calltmp2 = call void @printstr(ptr @str.49)
  %calltmp3 = call void @exit(i32 1)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp4 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp4 to i64
  %tmp_float5 = zext i32 %1 to i64
  %multmp = mul i64 %tmp_float5, i32 ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %addtmp = add i64 %tmp_int, %multmp
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  %readtmp6 = load %Hittable, ptr %tmp_pointer, align 8
  ret %Hittable %readtmp6
}

define %AABB @boundingBox_0.50(%Hittable %0) {
entry:
  %extracted = extractvalue %Hittable %0, 3
  %extracted1 = extractvalue %Hittable %0, 2
  %extracted2 = extractvalue %HittableVTable %extracted1, 1
  %calltmp = call %AABB %extracted2(ptr %extracted)
  %extracted3 = extractvalue %Hittable %0, 0
  %calltmp4 = call %AABB @offset_0(%AABB %calltmp, %Vec3 %extracted3)
  ret %AABB %calltmp4
}

define %AABB @offset_0(%AABB %0, %Vec3 %1) {
entry:
  %result = alloca %AABB, align 8
  %2 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 0
  %extracted = extractvalue %AABB %0, 0
  %extracted1 = extractvalue %Vec3 %1, 0
  %calltmp = call %Interval @offset_0.51(%Interval %extracted, float %extracted1)
  store %Interval %calltmp, ptr %2, align 4
  %3 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 1
  %extracted2 = extractvalue %AABB %0, 1
  %extracted3 = extractvalue %Vec3 %1, 1
  %calltmp4 = call %Interval @offset_0.51(%Interval %extracted2, float %extracted3)
  store %Interval %calltmp4, ptr %3, align 4
  %4 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 2
  %extracted5 = extractvalue %AABB %0, 2
  %extracted6 = extractvalue %Vec3 %1, 2
  %calltmp7 = call %Interval @offset_0.51(%Interval %extracted5, float %extracted6)
  store %Interval %calltmp7, ptr %4, align 4
  %readtmp = load %AABB, ptr %result, align 4
  ret %AABB %readtmp
}

define %Interval @offset_0.51(%Interval %0, float %1) {
entry:
  %extracted = extractvalue %Interval %0, 0
  %addtmp = fadd float %extracted, %1
  %extracted1 = extractvalue %Interval %0, 1
  %addtmp2 = fadd float %extracted1, %1
  %calltmp = call %Interval @new_0.14(float %addtmp, float %addtmp2)
  ret %Interval %calltmp
}

define %Interval @axis_0(%AABB %0, i32 %1) {
entry:
  %neqtmp = icmp eq i32 1, %1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %extracted = extractvalue %AABB %0, 1
  ret %Interval %extracted

ifmerge:                                          ; preds = %entry
  %neqtmp1 = icmp eq i32 2, %1
  %ifcond2 = icmp ne i1 %neqtmp1, false
  br i1 %ifcond2, label %ifbody3, label %ifmerge4

ifbody3:                                          ; preds = %ifmerge
  %extracted5 = extractvalue %AABB %0, 2
  ret %Interval %extracted5

ifmerge4:                                         ; preds = %ifmerge
  %extracted6 = extractvalue %AABB %0, 0
  ret %Interval %extracted6
}

define %Hittable @get_0.52(ptr %0, i32 %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp = load i32, ptr %2, align 4
  %subtmp = sub i32 %readtmp, 1
  %gttmp = icmp ugt i32 %1, %subtmp
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %tmp_float = zext i32 %readtmp1 to i64
  %calltmp = call void @printint(i64 %tmp_float)
  %calltmp2 = call void @printstr(ptr @str.53)
  %calltmp3 = call void @exit(i32 1)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp4 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp4 to i64
  %tmp_float5 = zext i32 %1 to i64
  %multmp = mul i64 %tmp_float5, i32 ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %addtmp = add i64 %tmp_int, %multmp
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  %readtmp6 = load %Hittable, ptr %tmp_pointer, align 8
  ret %Hittable %readtmp6
}

define ptr @getPtr_0(ptr %0, i32 %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp = load i32, ptr %2, align 4
  %subtmp = sub i32 %readtmp, 1
  %gttmp = icmp ugt i32 %1, %subtmp
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %tmp_float = zext i32 %readtmp1 to i64
  %calltmp = call void @printint(i64 %tmp_float)
  %calltmp2 = call void @printstr(ptr @str.54)
  %calltmp3 = call void @exit(i32 1)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp4 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp4 to i64
  %tmp_float5 = zext i32 %1 to i64
  %multmp = mul i64 %tmp_float5, i32 ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %addtmp = add i64 %tmp_int, %multmp
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  ret ptr %tmp_pointer
}

define ptr @getPtr_0.55(ptr %0, i32 %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp = load i32, ptr %2, align 4
  %subtmp = sub i32 %readtmp, 1
  %gttmp = icmp ugt i32 %1, %subtmp
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %tmp_float = zext i32 %readtmp1 to i64
  %calltmp = call void @printint(i64 %tmp_float)
  %calltmp2 = call void @printstr(ptr @str.56)
  %calltmp3 = call void @exit(i32 1)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp4 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp4 to i64
  %tmp_float5 = zext i32 %1 to i64
  %multmp = mul i64 %tmp_float5, i32 ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %addtmp = add i64 %tmp_int, %multmp
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  ret ptr %tmp_pointer
}

define ptr @getPtr_0.57(ptr %0, i32 %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp = load i32, ptr %2, align 4
  %subtmp = sub i32 %readtmp, 1
  %gttmp = icmp ugt i32 %1, %subtmp
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %tmp_float = zext i32 %readtmp1 to i64
  %calltmp = call void @printint(i64 %tmp_float)
  %calltmp2 = call void @printstr(ptr @str.58)
  %calltmp3 = call void @exit(i32 1)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp4 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp4 to i64
  %tmp_float5 = zext i32 %1 to i64
  %multmp = mul i64 %tmp_float5, i32 ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %addtmp = add i64 %tmp_int, %multmp
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  ret ptr %tmp_pointer
}

define ptr @getPtr_0.59(ptr %0, i32 %1) {
entry:
  %2 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp = load i32, ptr %2, align 4
  %subtmp = sub i32 %readtmp, 1
  %gttmp = icmp ugt i32 %1, %subtmp
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %3 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %3, align 4
  %tmp_float = zext i32 %readtmp1 to i64
  %calltmp = call void @printint(i64 %tmp_float)
  %calltmp2 = call void @printstr(ptr @str.60)
  %calltmp3 = call void @exit(i32 1)
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %entry
  %4 = getelementptr inbounds %ArrayList.7, ptr %0, i32 0, i32 2
  %readtmp4 = load ptr, ptr %4, align 8
  %tmp_int = ptrtoint ptr %readtmp4 to i64
  %tmp_float5 = zext i32 %1 to i64
  %multmp = mul i64 %tmp_float5, i32 ptrtoint (ptr getelementptr inbounds ([1 x %Hittable], ptr null, i32 1) to i32)
  %addtmp = add i64 %tmp_int, %multmp
  %tmp_pointer = inttoptr i64 %addtmp to ptr
  ret ptr %tmp_pointer
}

define %Hittable @new_1.61(ptr %0, %Vec3 %1) {
entry:
  %result = alloca %Hittable, align 8
  %readtmp = load %BHV, ptr %0, align 8
  %2 = getelementptr inbounds %Hittable, ptr %result, i32 0, i32 0
  store %Vec3 %1, ptr %2, align 4
  %3 = getelementptr inbounds %Hittable, ptr %result, i32 0, i32 1
  %calltmp = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  store %Vec3 %calltmp, ptr %3, align 4
  %4 = getelementptr inbounds %Hittable, ptr %result, i32 0, i32 2
  %5 = getelementptr inbounds %HittableVTable, ptr %4, i32 0, i32 0
  store ptr @checkHit_0.62, ptr %5, align 8
  %6 = getelementptr inbounds %Hittable, ptr %result, i32 0, i32 2
  %7 = getelementptr inbounds %HittableVTable, ptr %6, i32 0, i32 1
  store ptr @boundingBox_0.65, ptr %7, align 8
  %8 = getelementptr inbounds %Hittable, ptr %result, i32 0, i32 3
  store ptr %0, ptr %8, align 8
  %readtmp1 = load %Hittable, ptr %result, align 8
  ret %Hittable %readtmp1
}

define i1 @checkHit_0.62(ptr %0, %HRay %1, %Vec3 %2, %Interval %3, ptr %4) {
entry:
  %readtmp = load %BHV, ptr %0, align 8
  %extracted = extractvalue %BHV %readtmp, 2
  %calltmp = call i1 @hit_0(%AABB %extracted, %HRay %1, %Interval %3)
  %nottmp = xor i1 %calltmp, true
  %ifcond = icmp ne i1 %nottmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  ret i1 false

ifmerge:                                          ; preds = %entry
  %time = alloca %Interval, align 8
  store %Interval %3, ptr %time, align 4
  %extracted1 = extractvalue %BHV %readtmp, 0
  %readtmp2 = load %Interval, ptr %time, align 4
  %calltmp3 = call i1 @checkHit_0.64(%Hittable %extracted1, %Vec3 %2, %HRay %1, %Interval %readtmp2, ptr %4)
  %ifcond4 = icmp ne i1 %calltmp3, false
  br i1 %ifcond4, label %ifbody5, label %ifmerge6

ifbody5:                                          ; preds = %ifmerge
  %readtmp7 = load %Interval, ptr %time, align 4
  %extracted8 = extractvalue %Interval %readtmp7, 0
  %5 = getelementptr inbounds %HitRecord, ptr %4, i32 0, i32 2
  %readtmp9 = load float, ptr %5, align 4
  %calltmp10 = call %Interval @new_0.14(float %extracted8, float %readtmp9)
  store %Interval %calltmp10, ptr %time, align 4
  br label %ifmerge6

ifmerge6:                                         ; preds = %ifbody5, %ifmerge
  %extracted11 = extractvalue %BHV %readtmp, 1
  %readtmp12 = load %Interval, ptr %time, align 4
  %calltmp13 = call i1 @checkHit_0.64(%Hittable %extracted11, %Vec3 %2, %HRay %1, %Interval %readtmp12, ptr %4)
  %ortmp = or i1 %calltmp3, %calltmp13
  ret i1 %ortmp
}

define i1 @hit_0(%AABB %0, %HRay %1, %Interval %2) {
entry:
  %time = alloca %Interval, align 8
  store %Interval %2, ptr %time, align 4
  %t0 = alloca float, align 4
  %t1 = alloca float, align 4
  %i = alloca i32, align 4
  store i32 0, ptr %i, align 4
  br label %whilehead

whilehead:                                        ; preds = %ifmerge27, %entry
  %readtmp = load i32, ptr %i, align 4
  %lttmp = icmp ult i32 %readtmp, 3
  %docond = icmp ne i1 %lttmp, false
  br i1 %docond, label %whilebody, label %whilemerge

whilebody:                                        ; preds = %whilehead
  %extracted = extractvalue %HRay %1, 1
  %readtmp1 = load i32, ptr %i, align 4
  %calltmp = call float @axis_0.63(%Vec3 %extracted, i32 %readtmp1)
  %divtmp = fdiv float 1.000000e+00, %calltmp
  %extracted2 = extractvalue %HRay %1, 0
  %readtmp3 = load i32, ptr %i, align 4
  %calltmp4 = call float @axis_0.63(%Vec3 %extracted2, i32 %readtmp3)
  %readtmp5 = load i32, ptr %i, align 4
  %calltmp6 = call %Interval @axis_0(%AABB %0, i32 %readtmp5)
  %extracted7 = extractvalue %Interval %calltmp6, 0
  %subtmp = fsub float %extracted7, %calltmp4
  %multmp = fmul float %subtmp, %divtmp
  store float %multmp, ptr %t0, align 4
  %readtmp8 = load i32, ptr %i, align 4
  %calltmp9 = call %Interval @axis_0(%AABB %0, i32 %readtmp8)
  %extracted10 = extractvalue %Interval %calltmp9, 1
  %subtmp11 = fsub float %extracted10, %calltmp4
  %multmp12 = fmul float %subtmp11, %divtmp
  store float %multmp12, ptr %t1, align 4
  %lttmp13 = fcmp ule float %divtmp, 0.000000e+00
  %ifcond = icmp ne i1 %lttmp13, false
  br i1 %ifcond, label %ifbody, label %ifmerge

whilemerge:                                       ; preds = %whilehead
  ret i1 true

ifbody:                                           ; preds = %whilebody
  %readtmp14 = load float, ptr %t0, align 4
  %readtmp15 = load float, ptr %t1, align 4
  store float %readtmp15, ptr %t0, align 4
  store float %readtmp14, ptr %t1, align 4
  br label %ifmerge

ifmerge:                                          ; preds = %ifbody, %whilebody
  %3 = getelementptr inbounds %Interval, ptr %time, i32 0, i32 0
  %readtmp16 = load float, ptr %t0, align 4
  %4 = getelementptr inbounds %Interval, ptr %time, i32 0, i32 0
  %readtmp17 = load float, ptr %4, align 4
  %calltmp18 = call float @fmaxf(float %readtmp16, float %readtmp17)
  store float %calltmp18, ptr %3, align 4
  %5 = getelementptr inbounds %Interval, ptr %time, i32 0, i32 1
  %readtmp19 = load float, ptr %t1, align 4
  %6 = getelementptr inbounds %Interval, ptr %time, i32 0, i32 1
  %readtmp20 = load float, ptr %6, align 4
  %calltmp21 = call float @fminf(float %readtmp19, float %readtmp20)
  store float %calltmp21, ptr %5, align 4
  %7 = getelementptr inbounds %Interval, ptr %time, i32 0, i32 1
  %readtmp22 = load float, ptr %7, align 4
  %8 = getelementptr inbounds %Interval, ptr %time, i32 0, i32 0
  %readtmp23 = load float, ptr %8, align 4
  %lttmp24 = fcmp ule float %readtmp22, %readtmp23
  %ifcond25 = icmp ne i1 %lttmp24, false
  br i1 %ifcond25, label %ifbody26, label %ifmerge27

ifbody26:                                         ; preds = %ifmerge
  ret i1 false

ifmerge27:                                        ; preds = %ifmerge
  %readtmp28 = load i32, ptr %i, align 4
  %addtmp = add i32 %readtmp28, 1
  store i32 %addtmp, ptr %i, align 4
  br label %whilehead
}

define float @axis_0.63(%Vec3 %0, i32 %1) {
entry:
  %neqtmp = icmp eq i32 1, %1
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %extracted = extractvalue %Vec3 %0, 1
  ret float %extracted

ifmerge:                                          ; preds = %entry
  %neqtmp1 = icmp eq i32 2, %1
  %ifcond2 = icmp ne i1 %neqtmp1, false
  br i1 %ifcond2, label %ifbody3, label %ifmerge4

ifbody3:                                          ; preds = %ifmerge
  %extracted5 = extractvalue %Vec3 %0, 2
  ret float %extracted5

ifmerge4:                                         ; preds = %ifmerge
  %extracted6 = extractvalue %Vec3 %0, 0
  ret float %extracted6
}

define i1 @checkHit_0.64(%Hittable %0, %Vec3 %1, %HRay %2, %Interval %3, ptr %4) {
entry:
  %extracted = extractvalue %Hittable %0, 0
  %calltmp = call %Vec3 @add_0(%Vec3 %1, %Vec3 %extracted)
  %extracted1 = extractvalue %Hittable %0, 3
  %extracted2 = extractvalue %Hittable %0, 2
  %extracted3 = extractvalue %HittableVTable %extracted2, 0
  %calltmp4 = call i1 %extracted3(ptr %extracted1, %HRay %2, %Vec3 %calltmp, %Interval %3, ptr %4)
  ret i1 %calltmp4
}

define %AABB @boundingBox_0.65(ptr %0) {
entry:
  %readtmp = load %BHV, ptr %0, align 8
  %extracted = extractvalue %BHV %readtmp, 2
  ret %AABB %extracted
}

define %AABB @combine_0(%AABB %0, %AABB %1) {
entry:
  %result = alloca %AABB, align 8
  %2 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 0
  %extracted = extractvalue %AABB %1, 0
  %extracted1 = extractvalue %AABB %0, 0
  %calltmp = call %Interval @combine_0.66(%Interval %extracted, %Interval %extracted1)
  store %Interval %calltmp, ptr %2, align 4
  %3 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 1
  %extracted2 = extractvalue %AABB %1, 1
  %extracted3 = extractvalue %AABB %0, 1
  %calltmp4 = call %Interval @combine_0.66(%Interval %extracted2, %Interval %extracted3)
  store %Interval %calltmp4, ptr %3, align 4
  %4 = getelementptr inbounds %AABB, ptr %result, i32 0, i32 2
  %extracted5 = extractvalue %AABB %1, 2
  %extracted6 = extractvalue %AABB %0, 2
  %calltmp7 = call %Interval @combine_0.66(%Interval %extracted5, %Interval %extracted6)
  store %Interval %calltmp7, ptr %4, align 4
  %readtmp = load %AABB, ptr %result, align 4
  ret %AABB %readtmp
}

define %Interval @combine_0.66(%Interval %0, %Interval %1) {
entry:
  %extracted = extractvalue %Interval %0, 0
  %extracted1 = extractvalue %Interval %1, 0
  %calltmp = call float @fminf(float %extracted, float %extracted1)
  %extracted2 = extractvalue %Interval %0, 1
  %extracted3 = extractvalue %Interval %1, 1
  %calltmp4 = call float @fmaxf(float %extracted2, float %extracted3)
  %calltmp5 = call %Interval @new_0.14(float %calltmp, float %calltmp4)
  ret %Interval %calltmp5
}

declare ptr @calloc(i32, i32)

declare void @pthread_mutex_init(ptr, ptr)

define ptr @thread_0(ptr %0) {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %ray_origin = alloca %Vec3, align 8
  store i32 0, ptr %j, align 4
  br label %whilehead

whilehead:                                        ; preds = %whilemerge4, %entry
  %readtmp = load i32, ptr %j, align 4
  %1 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 1
  %readtmp1 = load i32, ptr %1, align 4
  %lttmp = icmp ult i32 %readtmp, %readtmp1
  %docond = icmp ne i1 %lttmp, false
  br i1 %docond, label %whilebody, label %whilemerge

whilebody:                                        ; preds = %whilehead
  store i32 0, ptr %i, align 4
  br label %whilehead2

whilemerge:                                       ; preds = %whilehead
  ret ptr null

whilehead2:                                       ; preds = %whilebody3, %whilebody
  %readtmp5 = load i32, ptr %i, align 4
  %2 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 0
  %readtmp6 = load i32, ptr %2, align 4
  %lttmp7 = icmp ult i32 %readtmp5, %readtmp6
  %docond8 = icmp ne i1 %lttmp7, false
  br i1 %docond8, label %whilebody3, label %whilemerge4

whilebody3:                                       ; preds = %whilehead2
  %3 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 2
  %readtmp9 = load ptr, ptr %3, align 8
  %tmp_int = ptrtoint ptr %readtmp9 to i64
  %readtmp10 = load i32, ptr %j, align 4
  %tmp_float = zext i32 %readtmp10 to i64
  %4 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 0
  %readtmp11 = load i32, ptr %4, align 4
  %tmp_float12 = zext i32 %readtmp11 to i64
  %multmp = mul i64 %tmp_float, %tmp_float12
  %readtmp13 = load i32, ptr %i, align 4
  %tmp_float14 = zext i32 %readtmp13 to i64
  %addtmp = add i64 %multmp, %tmp_float14
  %multmp15 = mul i64 %addtmp, zext (i32 ptrtoint (ptr getelementptr inbounds ([1 x %Color], ptr null, i32 1) to i32) to i64)
  %addtmp16 = add i64 %tmp_int, %multmp15
  %tmp_pointer = inttoptr i64 %addtmp16 to ptr
  %5 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 3
  %readtmp17 = load %Vec3, ptr %5, align 4
  %6 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 4
  %readtmp18 = load %Vec3, ptr %6, align 4
  %readtmp19 = load i32, ptr %i, align 4
  %tmp_float20 = uitofp i32 %readtmp19 to float
  %calltmp = call %Vec3 @mul_0(%Vec3 %readtmp18, float %tmp_float20)
  %7 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 5
  %readtmp21 = load %Vec3, ptr %7, align 4
  %readtmp22 = load i32, ptr %j, align 4
  %tmp_float23 = uitofp i32 %readtmp22 to float
  %calltmp24 = call %Vec3 @mul_0(%Vec3 %readtmp21, float %tmp_float23)
  %calltmp25 = call %Vec3 @add_0(%Vec3 %calltmp, %Vec3 %calltmp24)
  %calltmp26 = call %Vec3 @add_0(%Vec3 %readtmp17, %Vec3 %calltmp25)
  %8 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 4
  %readtmp27 = load %Vec3, ptr %8, align 4
  %9 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 5
  %readtmp28 = load %Vec3, ptr %9, align 4
  %calltmp29 = call %Vec3 @pixel_sample_square_0(%Vec3 %readtmp27, %Vec3 %readtmp28)
  %calltmp30 = call %Vec3 @add_0(%Vec3 %calltmp26, %Vec3 %calltmp29)
  %10 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 6
  %readtmp31 = load %Vec3, ptr %10, align 4
  store %Vec3 %readtmp31, ptr %ray_origin, align 4
  %calltmp32 = call double @random_double01()
  %tmp_trunc = fptrunc double %calltmp32 to float
  %readtmp33 = load %Vec3, ptr %ray_origin, align 4
  %calltmp34 = call %Vec3 @sub_0(%Vec3 %calltmp30, %Vec3 %readtmp33)
  %readtmp35 = load %Vec3, ptr %ray_origin, align 4
  %calltmp36 = call %Ray @new_0.67(%Vec3 %readtmp35, %Vec3 %calltmp34, float %tmp_trunc)
  %11 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 7
  %readtmp37 = load %Hittable, ptr %11, align 8
  %12 = getelementptr inbounds %ThreadArgs, ptr %0, i32 0, i32 8
  %readtmp38 = load %Color, ptr %12, align 4
  %calltmp39 = call %Color @color_0(%Ray %calltmp36, %Hittable %readtmp37, %Color %readtmp38, i32 100)
  %calltmp40 = call void @pthread_mutex_lock(ptr @globalPtr)
  %13 = getelementptr inbounds %Color, ptr %tmp_pointer, i32 0, i32 0
  %14 = getelementptr inbounds %Color, ptr %tmp_pointer, i32 0, i32 0
  %readtmp41 = load %Vec3, ptr %14, align 4
  %extracted = extractvalue %Color %calltmp39, 0
  %calltmp42 = call %Vec3 @add_0(%Vec3 %readtmp41, %Vec3 %extracted)
  store %Vec3 %calltmp42, ptr %13, align 4
  %calltmp43 = call void @pthread_mutex_unlock(ptr @globalPtr)
  %readtmp44 = load i32, ptr %i, align 4
  %addtmp45 = add i32 %readtmp44, 1
  store i32 %addtmp45, ptr %i, align 4
  br label %whilehead2

whilemerge4:                                      ; preds = %whilehead2
  %readtmp46 = load i32, ptr %j, align 4
  %addtmp47 = add i32 %readtmp46, 1
  store i32 %addtmp47, ptr %j, align 4
  br label %whilehead
}

define %Vec3 @pixel_sample_square_0(%Vec3 %0, %Vec3 %1) {
entry:
  %calltmp = call double @random_double01()
  %subtmp = fsub double %calltmp, 5.000000e-01
  %tmp_trunc = fptrunc double %subtmp to float
  %calltmp1 = call double @random_double01()
  %subtmp2 = fsub double %calltmp1, 5.000000e-01
  %tmp_trunc3 = fptrunc double %subtmp2 to float
  %calltmp4 = call %Vec3 @mul_0(%Vec3 %0, float %tmp_trunc)
  %calltmp5 = call %Vec3 @mul_0(%Vec3 %1, float %tmp_trunc3)
  %calltmp6 = call %Vec3 @add_0(%Vec3 %calltmp4, %Vec3 %calltmp5)
  ret %Vec3 %calltmp6
}

declare double @random_double01()

define %Ray @new_0.67(%Vec3 %0, %Vec3 %1, float %2) {
entry:
  %result = alloca %Ray, align 8
  %3 = getelementptr inbounds %Ray, ptr %result, i32 0, i32 0
  %4 = getelementptr inbounds %HRay, ptr %3, i32 0, i32 2
  store float %2, ptr %4, align 4
  %5 = getelementptr inbounds %Ray, ptr %result, i32 0, i32 0
  %6 = getelementptr inbounds %HRay, ptr %5, i32 0, i32 1
  store %Vec3 %1, ptr %6, align 4
  %7 = getelementptr inbounds %Ray, ptr %result, i32 0, i32 0
  %8 = getelementptr inbounds %HRay, ptr %7, i32 0, i32 0
  store %Vec3 %0, ptr %8, align 4
  %readtmp = load %Ray, ptr %result, align 4
  ret %Ray %readtmp
}

define %Color @color_0(%Ray %0, %Hittable %1, %Color %2, i32 %3) {
entry:
  %neqtmp = icmp eq i32 0, %3
  %ifcond = icmp ne i1 %neqtmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %calltmp = call %Color @new_0.1(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  ret %Color %calltmp

ifmerge:                                          ; preds = %entry
  %record = alloca %HitRecord, align 8
  %calltmp1 = call %Vec3 @new_0(float 0.000000e+00, float 0.000000e+00, float 0.000000e+00)
  %extracted = extractvalue %Ray %0, 0
  %calltmp2 = call %Interval @new_0.14(float 0x3F50624DE0000000, float 0x7FF0000000000000)
  %calltmp3 = call i1 @checkHit_0.64(%Hittable %1, %Vec3 %calltmp1, %HRay %extracted, %Interval %calltmp2, ptr %record)
  %nottmp = xor i1 %calltmp3, true
  %ifcond4 = icmp ne i1 %nottmp, false
  br i1 %ifcond4, label %ifbody5, label %ifmerge6

ifbody5:                                          ; preds = %ifmerge
  ret %Color %2

ifmerge6:                                         ; preds = %ifmerge
  %scattered = alloca %Ray, align 8
  %attenuation = alloca %Color, align 8
  %emission = alloca %Color, align 8
  %4 = getelementptr inbounds %HitRecord, ptr %record, i32 0, i32 6
  %readtmp = load ptr, ptr %4, align 8
  %readtmp7 = load %Material, ptr %readtmp, align 8
  %5 = getelementptr inbounds %HitRecord, ptr %record, i32 0, i32 3
  %readtmp8 = load float, ptr %5, align 4
  %6 = getelementptr inbounds %HitRecord, ptr %record, i32 0, i32 4
  %readtmp9 = load float, ptr %6, align 4
  %7 = getelementptr inbounds %HitRecord, ptr %record, i32 0, i32 0
  %readtmp10 = load %Vec3, ptr %7, align 4
  %calltmp11 = call %Color @emit_0.68(%Material %readtmp7, float %readtmp8, float %readtmp9, %Vec3 %readtmp10)
  store %Color %calltmp11, ptr %emission, align 4
  %8 = getelementptr inbounds %HitRecord, ptr %record, i32 0, i32 6
  %readtmp12 = load ptr, ptr %8, align 8
  %readtmp13 = load %Material, ptr %readtmp12, align 8
  %extracted14 = extractvalue %Ray %0, 0
  %calltmp15 = call i1 @scatter_0.69(%Material %readtmp13, %HRay %extracted14, ptr %record, ptr %attenuation, ptr %scattered)
  %nottmp16 = xor i1 %calltmp15, true
  %ifcond17 = icmp ne i1 %nottmp16, false
  br i1 %ifcond17, label %ifbody18, label %ifmerge19

ifbody18:                                         ; preds = %ifmerge6
  %readtmp20 = load %Color, ptr %emission, align 4
  ret %Color %readtmp20

ifmerge19:                                        ; preds = %ifmerge6
  %readtmp21 = load %Ray, ptr %scattered, align 4
  %subtmp = sub i32 %3, 1
  %calltmp22 = call %Color @color_0(%Ray %readtmp21, %Hittable %1, %Color %2, i32 %subtmp)
  %readtmp23 = load %Color, ptr %attenuation, align 4
  %extracted24 = extractvalue %Color %readtmp23, 0
  %calltmp25 = call float @dot_0(%Vec3 %extracted24, %Vec3 %extracted24)
  %lttmp = fcmp ule float %calltmp25, 0x3F847AE140000000
  %ifcond26 = icmp ne i1 %lttmp, false
  br i1 %ifcond26, label %ifbody27, label %ifmerge28

ifbody27:                                         ; preds = %ifmerge19
  %readtmp29 = load %Color, ptr %emission, align 4
  ret %Color %readtmp29

ifmerge28:                                        ; preds = %ifmerge19
  %9 = getelementptr inbounds %Color, ptr %attenuation, i32 0, i32 0
  %readtmp30 = load %Vec3, ptr %9, align 4
  %extracted31 = extractvalue %Color %calltmp22, 0
  %calltmp32 = call %Vec3 @mulV_0(%Vec3 %readtmp30, %Vec3 %extracted31)
  store %Vec3 %calltmp32, ptr %9, align 4
  %10 = getelementptr inbounds %Color, ptr %attenuation, i32 0, i32 0
  %readtmp33 = load %Vec3, ptr %10, align 4
  %11 = getelementptr inbounds %Color, ptr %emission, i32 0, i32 0
  %readtmp34 = load %Vec3, ptr %11, align 4
  %calltmp35 = call %Vec3 @add_0(%Vec3 %readtmp33, %Vec3 %readtmp34)
  store %Vec3 %calltmp35, ptr %10, align 4
  %readtmp36 = load %Color, ptr %attenuation, align 4
  ret %Color %readtmp36
}

define %Color @emit_0.68(%Material %0, float %1, float %2, %Vec3 %3) {
entry:
  %extracted = extractvalue %Material %0, 1
  %extracted1 = extractvalue %Material %0, 0
  %extracted2 = extractvalue %MaterialVTable %extracted1, 1
  %calltmp = call %Color %extracted2(ptr %extracted, float %1, float %2, %Vec3 %3)
  ret %Color %calltmp
}

define i1 @scatter_0.69(%Material %0, %HRay %1, ptr %2, ptr %3, ptr %4) {
entry:
  %extracted = extractvalue %Material %0, 1
  %extracted1 = extractvalue %Material %0, 0
  %extracted2 = extractvalue %MaterialVTable %extracted1, 0
  %calltmp = call i1 %extracted2(ptr %extracted, %HRay %1, ptr %2, ptr %3, ptr %4)
  ret i1 %calltmp
}

define %Vec3 @mulV_0(%Vec3 %0, %Vec3 %1) {
entry:
  %extracted = extractvalue %Vec3 %0, 0
  %extracted1 = extractvalue %Vec3 %1, 0
  %multmp = fmul float %extracted, %extracted1
  %extracted2 = extractvalue %Vec3 %0, 1
  %extracted3 = extractvalue %Vec3 %1, 1
  %multmp4 = fmul float %extracted2, %extracted3
  %extracted5 = extractvalue %Vec3 %0, 2
  %extracted6 = extractvalue %Vec3 %1, 2
  %multmp7 = fmul float %extracted5, %extracted6
  %calltmp = call %Vec3 @new_0(float %multmp, float %multmp4, float %multmp7)
  ret %Vec3 %calltmp
}

declare void @pthread_mutex_lock(ptr)

declare void @pthread_mutex_unlock(ptr)

declare void @pthread_create(ptr, ptr, ptr, ptr)

declare void @log_pc(i32, i32)

declare void @pthread_join(ptr, ptr)

define [3 x i8] @bytes_0(%Color %0, float %1) {
entry:
  %calltmp = call %Interval @new_0.14(float 0.000000e+00, float 0x3FEFF7CEE0000000)
  %extracted = extractvalue %Color %0, 0
  %divtmp = fdiv float 1.000000e+00, %1
  %calltmp1 = call %Vec3 @mul_0(%Vec3 %extracted, float %divtmp)
  %result = alloca [3 x i8], align 1
  %elemtemp = getelementptr inbounds [3 x i8], ptr %result, i32 0, i32 0
  %extracted2 = extractvalue %Vec3 %calltmp1, 0
  %calltmp3 = call float @linear_to_gamma_0(float %extracted2)
  %calltmp4 = call float @clamp_0(%Interval %calltmp, float %calltmp3)
  %multmp = fmul float %calltmp4, 2.560000e+02
  %tmp_float = fptoui float %multmp to i8
  store i8 %tmp_float, ptr %elemtemp, align 1
  %elemtemp5 = getelementptr inbounds [3 x i8], ptr %result, i32 0, i32 1
  %extracted6 = extractvalue %Vec3 %calltmp1, 1
  %calltmp7 = call float @linear_to_gamma_0(float %extracted6)
  %calltmp8 = call float @clamp_0(%Interval %calltmp, float %calltmp7)
  %multmp9 = fmul float %calltmp8, 2.560000e+02
  %tmp_float10 = fptoui float %multmp9 to i8
  store i8 %tmp_float10, ptr %elemtemp5, align 1
  %elemtemp11 = getelementptr inbounds [3 x i8], ptr %result, i32 0, i32 2
  %extracted12 = extractvalue %Vec3 %calltmp1, 2
  %calltmp13 = call float @linear_to_gamma_0(float %extracted12)
  %calltmp14 = call float @clamp_0(%Interval %calltmp, float %calltmp13)
  %multmp15 = fmul float %calltmp14, 2.560000e+02
  %tmp_float16 = fptoui float %multmp15 to i8
  store i8 %tmp_float16, ptr %elemtemp11, align 1
  %readtmp = load [3 x i8], ptr %result, align 1
  ret [3 x i8] %readtmp
}

define float @linear_to_gamma_0(float %0) {
entry:
  %calltmp = call float @sqrtf(float %0)
  ret float %calltmp
}

define float @clamp_0(%Interval %0, float %1) {
entry:
  %extracted = extractvalue %Interval %0, 0
  %gttmp = fcmp uge float %extracted, %1
  %ifcond = icmp ne i1 %gttmp, false
  br i1 %ifcond, label %ifbody, label %ifmerge

ifbody:                                           ; preds = %entry
  %extracted1 = extractvalue %Interval %0, 0
  ret float %extracted1

ifmerge:                                          ; preds = %entry
  %extracted2 = extractvalue %Interval %0, 1
  %lttmp = fcmp ule float %extracted2, %1
  %ifcond3 = icmp ne i1 %lttmp, false
  br i1 %ifcond3, label %ifbody4, label %ifmerge5

ifbody4:                                          ; preds = %ifmerge
  %extracted6 = extractvalue %Interval %0, 1
  ret float %extracted6

ifmerge5:                                         ; preds = %ifmerge
  ret float %1
}

declare ptr @get_name(i32)

declare void @stbi_write_png(ptr, i32, i32, i32, ptr, i32)

define void @write_0(%Color %0, float %1) {
entry:
  %calltmp = call %Interval @new_0.14(float 0.000000e+00, float 0x3FEFF7CEE0000000)
  %extracted = extractvalue %Color %0, 0
  %divtmp = fdiv float 1.000000e+00, %1
  %calltmp1 = call %Vec3 @mul_0(%Vec3 %extracted, float %divtmp)
  %extracted2 = extractvalue %Vec3 %calltmp1, 0
  %calltmp3 = call float @linear_to_gamma_0(float %extracted2)
  %calltmp4 = call float @clamp_0(%Interval %calltmp, float %calltmp3)
  %multmp = fmul float %calltmp4, 2.560000e+02
  %tmp_float = fptoui float %multmp to i64
  %calltmp5 = call void @printint(i64 %tmp_float)
  %calltmp6 = call void @printstr(ptr @str.70)
  %extracted7 = extractvalue %Vec3 %calltmp1, 1
  %calltmp8 = call float @linear_to_gamma_0(float %extracted7)
  %calltmp9 = call float @clamp_0(%Interval %calltmp, float %calltmp8)
  %multmp10 = fmul float %calltmp9, 2.560000e+02
  %tmp_float11 = fptoui float %multmp10 to i64
  %calltmp12 = call void @printint(i64 %tmp_float11)
  %calltmp13 = call void @printstr(ptr @str.71)
  %extracted14 = extractvalue %Vec3 %calltmp1, 2
  %calltmp15 = call float @linear_to_gamma_0(float %extracted14)
  %calltmp16 = call float @clamp_0(%Interval %calltmp, float %calltmp15)
  %multmp17 = fmul float %calltmp16, 2.560000e+02
  %tmp_float18 = fptoui float %multmp17 to i64
  %calltmp19 = call void @printint(i64 %tmp_float18)
  %calltmp20 = call void @printstr(ptr @str.72)
  ret void
}
